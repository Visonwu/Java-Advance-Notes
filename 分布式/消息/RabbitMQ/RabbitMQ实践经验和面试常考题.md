# 一、实践经验总结

## 1.1 资源管理

### 1) 资源到底在消费者创建还是在生产者创建？

-  一般在消费者创建，一般由谁消费谁管理负责；

- 但是实际在公司中**交换机和队列**，实际上是作为资源，由运维管理员创建的。

### 2）如果A 项目和B 项目有相互发送和接收消息，应该创建几个vhost，几个Exchange？

​		

### 3）为什么交换机和队列仍然需要在代码中定义？重复创建不报错吗？

​		我们只是在代码中使用到这些信息，并不是要创建它，如果已经存在了这些信息是直接使用的（创建一模一样的队列直接返回成功）



## 1.2 文件命令规范

1、元数据的命名集中放在properties 文件中，不要用硬编码。如果有多个系统，
		可以配置多个xxx_mq.properties。

2、命名体现元数据的类型

- 虚拟机命名： XXX_VHOST
- 交换机命名：XXX_EXCHANGE

- 队列命名：xxx_QUEUE

3、命名体现数据来源和去向
       例如：销售系统发往产品系统的交换机：SALE_TO_PRODUCT_EXCHANGE。做到见名知义，不用去查文档（当然注释是必不可少的）。

## 1.3 消息落库

​		将需要发送的消息保存在数据库中，可以实现消息的可追溯和重复控制，需要配合定时任务来实现。

- 1） 将需要发送的消息登记在消息表中。

- 2） 定时任务一分钟或半分钟扫描一次，将未发送的消息发送到MQ 服务器，并且修改状态为已发送。
- 3） 如果需要重发消息，将指定消息的状态修改为未发送即可。
  		副作用：降低效率，浪费存储空间。

## 1.4. 生产环境运维监控

​		虽然RabbitMQ 提供了一个简单的管理界面，但是如果对于系统性能、高可用和其他参数有一些定制化的监控需求的话，我们就需要通过其他方式来实现监控了。
​		主要关注：磁盘、内存、连接数



## 1.5 日志追踪

​	RabbitMQ 可以通过Firehose 功能来记录消息流入流出的情况，用于调试，排错。

​		它是通过创建一个TOPIC 类型的交换机（amq.rabbitmq.trace），把生产者发送给Broker 的消息或者Broker 发送给消费者的消息发到这个默认的交换机上面来实现的。

​		另外RabbitMQ 也提供了一个Firehose 的GUI 版本，就是Tracing 插件。启用Tracing 插件后管理界面右侧选项卡会多一个Tracing，可以添加相应的策略。

RabbitMQ 还提供了其他的插件来增强功能。

https://www.rabbitmq.com/firehose.html
https://www.rabbitmq.com/plugins.html



## 1.6  如何减少连接数
​		在发送大批量消息的情况下，创建和释放连接依然有不小的开销。我们可以跟接收方约定批量消息的格式，比如支持JSON 数组的格式，通过合并消息内容，可以减少生产者/消费者与Broker 的连接。

建议单条消息不要超过4M（4096KB），一次发送的消息数需要合理地控制。



# 二、常见面试题

## 1 消息队列的作用与使用场景？

异步：批量数据异步处理。例：批量上传文件，比如代发代扣文件。
削峰：高负载任务负载均衡。例：电商秒杀抢购。
解耦：串行任务并行化。例：退货流程解耦。
广播：基于Pub/Sub实现一对多通信



## 2 多个消费者监听一个队列时，消息如何分发？
**1、Round-Robin（轮询）**
​	默认的策略，消费者轮流、平均地收到消息。

**2、Fair dispatch （公平分发）**
​	如果要实现根据消费者的处理能力来分发消息，给空闲的消费者发送更多消息，可以用basicQos(int
prefetch_count)来设置。prefetch_count的含义：当消费者有多少条消息没有响应ACK时，不再给这个消费者发送消息。



## 3 无法被路由的消息，去了哪里？
如果没有任何设置，无法路由的消息会被直接丢弃。

无法路由的情况：Routing key不正确。
解决方案：
1、使用 mandatory=true 配合 ReturnListener，实现消息回发。
2、声明交换机时，指定备份交换机。

## 4 消息在什么时候会变成Dead Letter（死信）？
1、消息被拒绝并且没有设置重新入队：(NACK || Reject ) && requeue == false
2、消息过期（消息或者队列的TTL设置）
3、消息堆积，并且队列达到最大长度，先入队的消息会变成DL。

可以在声明队列时，指定一个Dead Letter Exchange，来实现Dead Letter的转发。



## 5.RabbitMQ如何实现延时队列？
- 1）利用TTL（队列的消息存活时间或消息存活时间），加上死信交换机。
- 2）当然还有一种方式就是先保存消息到数据库，用调度器扫描发送（时间不够精准）。

- 3）或者延迟队列插件。

## 6. 如何保证消息的可靠性投递？

1、确保投递到服务端Broker
2、保证正确地路由
3、消息的持久化存储
4、消费者应答ACK
5、消费者回调
6、补偿机制



## 7. 消息幂等性
首先，Broker本身没有消息重复过滤的机制。
1、生产者方面，可以对每条消息生成一个msgId，以此控制消息重复投递。

```java
// 消息属性
AMQP.BasicProperties properties = new AMQP.BasicProperties.Builder()
   .messageId(String.valueOf(UUID.randomUUID()))
   .build();
// 发送消息
channel.basicPublish("", QUEUE_NAME, properties, msg.getBytes());
```

2、消费者方面，消息体（比如json报文）中必须携带一个业务ID，比如银行的交易流水号，消费者可以根据业务
ID去重，避免重复消费。



## 8. 如何在服务端和消费端做限流？
- 网关/接入层：其他限流方式。
- 服务端（Broker）：配置文件中内存和磁盘的控制；队列长度无法实现限流。
- 消费端：prefetch_count。



## 9.如何保证消息的顺序性？

比如新增门店、绑定产品、激活门店这种对消息顺序要求严格的场景。

- 一个队列只有一个消费者的情况下才能保证顺序。
- 否则只能通过全局ID来实现。
  - 1、每条消息有一个msgId，关联的消息拥有同一个parentMsgId。
    2、可以在消费端实现前一条消息未消费，不处理下一条消息；也可以在生产端实现前一条消息未处理完毕，不发布下一条消息



## 10.一个队列最多可以存取多少条消息

-  取决于我们队列的数据是否存放在磁盘上还是内存上，如果是磁盘性会存储在磁盘上；如果是内存性就会存储在内存中，但是如果使用了持久化，即使是内存性也会存储在磁盘上；所以还是取决于我们的硬件配置



- 另外如果队列配置了队列数量的大小或者长度也是影响存取消息的



## 11. 如果提高消息的消费速率

​	增加消费者



## 12. 如何动态的创建队列和消费者

​		通过`SimpleMessageListenerContainer`来动态增加队列和消费者



## 13. 大量消息堆积怎么办？

​	堆积产生原因：队头某个消费不能被消费，产生堆积；或者消费速率过慢；然后对症下药

- 方式一：**重启机器**，这样消费者就会尝试重新去消息队头的消息，还是需要去解决代码的问题
- 方式二：**增加消费者**，如果是因为生产速率快，或者消费速率慢
- 方式三：**purge(管理界面)消息，清空消息**，如果消息不是特别重要，例如通知或者日志信息，然后再重发



## 14 .MQ的选型

- 使用和管理：（api使用，社区活跃度），（管理，监控）
- 性能：并发，吞吐量，消息堆积能力
- 功能：顺序性，事务，消息延迟，优先级等
- 可用性，可靠性，持久化，集群等



## 15.自己设计MQ思路

存储：磁盘/数据库，内存

转发：通信（http/amqp等协议），消息路由方式（一对一，一对多），推或者拉模式获取消息

然后考虑其他功能性：高可用，吞吐量等



## 16.RabbitMQ的集群模式和集群节点类型？

集群模式有两种：
​	**普通模式**：默认模式，以两个节点（rabbit01、rabbit02）为例来进行说明。对于Queue来说，消息实体只存在于其中一个节点rabbit01（或者rabbit02），rabbit01和rabbit02两个节点仅有相同的元数据，即队列的结构。当消息进入rabbit01节点的Queue后，consumer从rabbit02节点消费时，RabbitMQ会临时在rabbit01、rabbit02间进行消息传输，把A中的消息实体取出并经过B发送给consumer。所以consumer应尽量连接每一个节点，从中取消息。即对于同一个逻辑队列，要在多个节点建立物理Queue。否则无论consumer连rabbit01或rabbit02，出口总在rabbit01，会产生瓶颈。当rabbit01节点故障后，rabbit02节点无法取到rabbit01节点中还未消费的消息实体。如果做了消息持久化，那么得等rabbit01节点恢复，然后才可被消费；如果没有持久化的话，就会产生消息丢失的现象。

​	**镜像模式**：把需要的队列做成镜像队列，存在与多个节点属于RabbitMQ的HA方案。该模式解决了普通模式中的问题，其实质和普通模式不同之处在于，消息实体会主动在镜像节点间同步，而不是在客户端取数据时临时拉取。该模式带来的副作用也很明显，除了降低系统性能外，如果镜像队列数量过多，加之大量的消息进入，集群内部的网络带宽将会被这种同步通讯大大消耗掉。所以在对可靠性要求较高的场合中适用。

**节点**分为两种：

- 1）内存(RAM)：保存状态到内存（但持久化的队列和消息还是会保存到磁盘）。
- 2）磁盘节点：保存状态到内存和磁盘。

一个集群中至少需要需要一个磁盘节点



## 17.如果一个项目要从多个服务器接收消息，怎么做？如果一个项目要发送消息到多个服务器，怎么做？
​	定义多个ConnectionFactory，注入到消费者监听类/Temaplate。