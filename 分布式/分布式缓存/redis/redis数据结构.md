# 1. Redis的特点

- 1>:Redis采用的是基于内存的采用的是**单进程单线程**模型的**KV**数据库

-  2>:基于内存的(信息是在内存中的 访问的速度特别快)

- 3>:数据结构简单(Key-Value)

- 4>:支持数据的持久化(能够将内存中的数据同步到硬盘)

- 5>使用16个db存储，相互隔离，默认用第0个db

## 2. 存储结构

​     大家一定对字典类型的数据结构非常熟悉，比如map ，通过key value的方式存储的结构。 redis的全称是remote dictionary server(远程字典服务器)，它以字典结构存储数据，并允许其他应用通过TCP协议读写字典中的内容。数据结构如下：

![](http://ww1.sinaimg.cn/large/b8a27c2fgy1g1kz1ouhmgj20ku06h74j.jpg)

# 2.Redis 的数据类型

redis的数据结构都是

```c
typdef struct redisObject{
    unsigned type:4;//类型
    
    unsigned encoding:4;//编码
    
    void * prt; //指向底层数据结构的指针
    //...
}
```

type类型如下，

```bash
redis> type key 
//通过如上命令 可以获取当前key的类型
```



![nigWPe.jpg](https://s2.ax1x.com/2019/09/02/nigWPe.jpg)

编码的底层数据有：

```bash
redis>object encoding key
//通过如上命令可以获取当前key所存在的底层数据结构信息
```



![nigIKI.png](https://s2.ax1x.com/2019/09/02/nigIKI.png)

## 2.1 字符串类型 - String

​      字符串类型是redis中最基本的数据类型，它能存储任何形式的字符串，包括二进制数据，int,float,double类型。你可以用它存储用户的邮箱、json化的对象甚至是图片。一个字符类型键允许存储的最大容量是512M

**应用场景**：普通的数据缓存这种一般就放到这里面  应用场景比较广   因为他就是一个键值对的字符串而已



**内部结构：**在Redis内部，String类型通过 int、SDS(simple dynamic string)作为结构存储，int用来存放整型数据，sds存放字节/字符串和浮点型数据。在C的标准字符串结构下进行了封装，用来提升基本操作的性能，同时也充分利用已有的C的标准库，简化实现逻辑

编码：int（整数）、raw（redisObject+SDS）或embstr（redisObject+embstr编码的SDS）

- 若是整数值，并且该整数值可以用long类型表示，则编码为int；
- 若是字符串值，并且字符串长度大于32字节，那么将使用SDS保存字符串值，编码为raw；
- 若是字符串值，并且字符串长度小于等于32字节，则编码为embstr。

注意：

- long double类型的浮点数是用字符串保存的，对其操作会先转化为浮点型进行操作再转化为字符串保存。
- 对int型操作（如APPEND一个字符串），会把int转化为raw。
- embstr字符串为只读，若要对其修改会先转化为raw。

注：embstr其实也是sds结构，只是embstr将创建字符串的内存分配有raw的两次降低为一次了，所有数据都放在放在一块连续的内存中，并且释放当前的embstr也只需要调用一次就可以了

##  2.2 列表类型 - List(可以重复的)

​     列表类型(list)可以存储一个有序的字符串列表，常用的操作是向列表两端添加元素或者获得列表的某一个片段。

**应用场景:**博客的关注、博客的评论、博客的积分可以实现消息队列功能

**内部结构** ：之前是ziplist和linkedlist实现的；redis3.2之后，采用的一种叫quicklist的数据结构来存储list，列表的底层都由quicklist实现

在redis3.2之前的情况是：

- 当列表对象保存的字符串元素都小于64字节，并且元素数量小于512个时，使用ziplist；
- 否则使用linkedlist，每个节点保存一个字符串对象。

在redis3.2之后是使用quicklist来保存

- linkedlist和ziplist的结合体



##  2.3 Hash类型 (Java中的Map)

**应用场景**:SSO单点登录



 **内部结构：**    map提供两种结构来存储，一种是字典（包含hashtable）、另一种是前面讲的ziplist，数据量小的时候用ziplist. 

- 哈希对象中保存的所有键值对的键和值的字符串长度都小于64字节，并且键值对数量小于512个，使用ziplist；
- 否则使用hashtable，键和值都为字符串对象。

注：ziplist存储的时候现将压缩键节点推入到压缩列表表尾，然后再讲保存的了值得节点推入列表表尾



##   2.4 集合类型 - Set(无序但是不重复)：

​    集合类型中，每个元素都是不同的，也就是不能有重复数据，同时集合类型中的数据是无序的。一个集合类型键可以存储至多2的32次方-1个 。集合类型和列表类型的最大的区别是有序性和唯一性

**应用场景**:：每个用户的关注的人在一个集合中，很容易实现两个人的共同好友

**内部结构:** Set在的底层数据结构以intset或者字典（hashtable）来存储。当set中只包含整数型的元素时，采用intset来存储，否则，采用hashtable存储，但是对于set来说，该hashtable的value值用于为NULL。通过key来存储元素



- 集合对象保存的所有元素都是整数值，并且数量不超过512个时，使用intset；这个数量可以通过`set-max-intset-entries`配置
- 否则使用hashtable，若使用hashtable，每个键都为一个字符串对象，值为NULL。



## 2.5 有序集合 - SortedSet

**应用场景**:最新最热的商品(有序)

**内部结构:**zset类型的数据结构就比较复杂一点，内部是以ziplist或者 字典+跳跃表来实现，这里面最核心的一个结构就是skiplist，也就是跳跃表      		



- 有序结合保存的元素数量小于128个，并且元素成员长度小于64字节，使用ziplist，每个结合元素使用两个压缩列表节点保存，第一个保存成员，第二个保存分数，集合元素按分值从小到大排序；

- 否则使用skiplist编码，底层为zset结构，包含一个字典和一个跳跃表，其中跳跃表按分值进行排序，实现了范围查询；而字典创建了从成员到分数的映射，键为集合元素，值为分数；字典和跳跃表都使用指针指向成员和分数，因此不会造成内存浪费

  - 这种结构如下

  - ```c
    typedef struct zset{
        zskiplist * zsl;//跳跃表
        dict *dict; //字典
    }
    ```

  - 



# 3.对象共享

让多个键共享一个值的对象，包含上面各种类型的指针指向这个的对象

- 将数据库键的值指针指向一个现有的值对象

- 将被共享的值对象的应用计数法增一（主要是用来内存回收用的，和Java的可达性分析算法不同）

  

​		目前来说redis会在初始化服务器创建一万个字符串对象，这些对象包含了0-9999的所有整数值，当服务器需要用到这些字符串对象时，就会共享这些对象而不是新创建对象。

```bash
redis> object refcount key
//可以通过这个命令获取当前key被引用的次数
```



# 4.对象空转时长

redisObject结构中还包含了lru属性，记录了对象最后一次被命令程序访问的时间，

```bash
redis> object idletime key
//这个可以答应出该键的空转时长，即没有读写该键
```

这个和服务器的内存回收算法volatile-lru和allkeys-lru有关系