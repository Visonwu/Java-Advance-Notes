# 1.Redis过期时间

## 1.1 命令使用

> 1）`EXPIRE key seconds`: 设置过期时间

 	其中seconds 参数表示键的过期时间，**单位为秒**。
​	EXPIRE 返回值为1表示设置成功，0表示设置失败或者键不存在

如果需要精确控制时间，可以使用`PEXPIRE` :单位是毫秒



> 2）`TTL key`：查看过期时间还剩多少
>
> 当键不存在时，TTL命令会返回-2
> 而对于没有给指定键设置过期时间的，通过TTL命令会返回-1



> 3）`setex(String key,int seconds,String value)`:针对字符串独有的过期时间设置



> 4）`PERSIST key `:该键恢复成为永久的

## 1.2  过期删除的原理

​    Redis 中的主键失效是如何实现的，即失效的主键是如何删除的？实际上，Redis 删除失效主键的方法主要有两
种。

### 1） 消极方法（passive way）
​	在主键被访问时如果发现它已经失效，那么就删除它

### 2）积极方法（active way）

​	周期性地从设置了失效时间的主键中选择一部分失效的主键删除。

​       对于那些从未被查询的key，即便它们已经过期，消极方式也无法清除。因此Redis会周期性地随机测试一些key，已过期的key将会被删掉。Redis每秒会进行10次操作，具体的流程：

- a:随机测试 20 个带有timeout信息的key；
- b:删除其中已经过期的key；
- c:如果超过25%的key被删除，则重复执行步骤a；

​      这是一个简单的概率算法（trivial probabilistic algorithm），基于假设我们随机抽取的key代表了全部的key空
间。

# 2.发布订阅

​      Redis提供了发布订阅功能，可以用于消息的传输，Redis提供了一组命令可以让开发者实现“发布/订阅”模式(publish/subscribe) . 该模式同样可以实现进程间的消息传递，它的实现原理是：

​     发布/订阅模式包含两种角色，分别是发布者和订阅者。订阅者可以订阅一个或多个频道，而发布者可以向指定的频道发送消息，所有订阅此频道的订阅者都会收到该消息；

> 发布者发布消息的命令是PUBLISH， 用法是`PUBLISH channel message`
>
> 比如向channel.1发一条消息:hello
> ​	`PUBLISH channel.1 “hello”`



​    这样就实现了消息的发送，该命令的返回值表示接收到这条消息的订阅者数量。因为在执行这条命令的时候还没有订阅者订阅该频道，所以返回为0. 另外值得注意的是**消息发送出去不会持久化**，如果发送之前没有订阅者，那么后续再有订阅者订阅该频道，之前的消息就收不到了.



> 订阅者订阅消息的命令是
> ​	SUBSCRIBE channel [channel …]
> 该命令同时可以订阅多个频道，比如订阅channel.1的频道。 SUBSCRIBE channel.1执行SUBSCRIBE命令后客户端会进入订阅状态



# 3. 持久化

​		Redis支持两种方式的持久化，一种是RDB方式、另一种是AOF（append-only-file）方式。两种持久化方式可以单独使用其中一种，也可以将这两种方式结合使用。

- RDB会根据指定的规则“定时”将内存中的数据存储在硬盘上；（默认使用）

- AOF后者在每次执行命令后将命令本身记录下来。(需要打开设置)



## 3.1 RDB

​     当符合一定条件时，Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个**临时文件**中，等到持久化过程都结束了，再用这个**临时文件替换上次持久化好的文件**。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。



**1）RDB的缺点：**是最后一次持久化后的数据可能丢失;

​       fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。



**2）Redis会在以下几种情况下对数据进行快照：**

- a: 根据配置规则进行自动快照
  - 见下面操作
- b: 用户执行SAVE或者GBSAVE命令
  - SAVE是阻塞的，通过命令方式完成快照会阻塞其他客户端请求，生产上不建议使用
  - GBSAVE:可以在后台异步地进行快照操作，快照的同时服务器还可以继续响应来自客户端的请求
- c: 执行FLUSHALL命令
  - 会清除redis在内存中的所有数据。执行该命令后，只要redis中配置的快照规则不为空，redis就会执行一次快照操作，不管规则是什么样的都会执行。如果没有定义快照规则，就不会执行快照操作
  - d: 执行复制(replication)时
  - 该操作主要是在主从模式下，redis会在复制初始化时进行自动快照。



**3）根据配置规则进行自动快照**

​	Redis允许用户自定义快照条件,在配置文件中配置：

```xml
配置格式如下:
save param01 param02 
   第一个参数是时间窗口(单位秒)，第二个是键的个数，也就是说，在第一个时间参数配置范围内被更改的键的个数大于后面的changes时，即符合快照条件。redis默认配置了三个规则:
save 900 1
save 300 10
save 60 10000
每条快照规则占一行，每条规则之间是“或”的关系。 在900秒（15分）内有一个以上的键被更改则进行快照。
```



## 3.2 AOF(appendonly file)

​         当使用Redis存储非临时数据时，一般需要打开AOF持久化来降低进程终止导致的数据丢失。AOF可以将Redis执行的每一条写命令追加到硬盘文件中，这一过程会降低Redis的性能，但大部分情况下这个影响是能够接受的，另外使用较快的硬盘可以提高AOF的性能。

**1）开启AOP持久化模式**

​      默认情况下Redis没有开启AOF（append only file）方式的持久化，可以通过appendonly参数启用，在redis.conf中找到 `appendonly yes`

```java
相关解释：
      \#只要有一个key发生改变那么立马和后台同步  这种模式不会丢数据但是  效率不高  一般不推荐
      \# appendfsync always

      \# 这个表示每秒钟和硬盘同步一次，官方推荐这种模式
      appendfsync everysec

      \# 这个和内存的缓冲区有关 缓冲区满了自动同步  没满的话那么就只有等
      \# appendfsync no
```



​    开启AOF持久化后每执行一条会更改Redis中的数据的命令后，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是apendonly.aof. 可以在redis.conf中的属性 appendfilename appendonlyh.aof修改

```xml
执行命令：
set foo 1
set foo 2
set foo 3
get      

    我们会发现AOF文件的内容正是Redis发送的原始通信协议的内容，从内容中我们发现Redis只记录了3
条命令。然后这时有一个问题是前面2条命令其实是冗余的，因为这两条的执行结果都会被第三条命令覆
盖。随着执行的命令越来越多，AOF文件的大小也会越来越大，其实内存中实际的数据可能没有多少，
那这样就会造成磁盘空间以及redis数据还原的过程比较长的问题。因此我们希望Redis可以自动优化
AOF文件，就上面这个例子来说，前面两条是可以被删除的。 

而实际上Redis也考虑到了，可以配置一个条件，每当达到一定条件时Redis就会自动重写AOF文件，这个条件的配置为：
auto-aof-rewrite-percentage 100 
auto-aof-rewrite-min-size 64mb

auto-aof-rewrite-percentage 表示的是当目前的AOF文件大小超过上一次重写时的AOF文件大小的百分之多少时会再次进行重写，如果之前没有重写过，则以启动时AOF文件大小为依据

auto-aof-rewrite-min-size 表示限制了允许重写的最小AOF文件大小，通常在AOF文件很小的情况下即使其中有很多冗余的命令我们也并不太关心

还可以通过BGREWRITEAOF 命令手动执行AOF，执行完以后冗余的命令已经被删除了
```



**2）AOF的重写原理**

​     Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。

​       重写的流程是这样，主进程会fork一个子进程出来进行AOF重写，这个重写过程并不是基于原有的aof文件来做的，而是有点类似于快照的方式，全量遍历内存中的数据，然后逐个序列到aof文件中。

​       在fork子进程这个过程中，服务端仍然可以对外提供服务，那这个时候重写的aof文件的数据和redis内存数据不一致了怎么办？不用担心，这个过程中，主进程的数据更新操作，会缓存到aof_rewrite_buf中，也就是单独开辟一块缓存来存储重写期间收到的命令，当子进程重写完以后再把缓存中的数据追加到新的aof文件。当所有的数据全部追加到新的aof文件中后，把新的aof文件重命名为，此后所有的操作都会被写入新的aof文件。如果在rewrite过程中出现故障，不会影响原来aof文件的正常工作，只有当rewrite完成后才会切换文件。因此这个rewrite过程是比较可靠的。

# 4.Redis内存回收策略

​    Redis中提供了多种内存回收策略，当内存容量不足时，为了保证程序的运行，这时就不得不淘汰内存中的一些对象，释放这些对象占用的空间，那么选择淘汰哪些对象呢？

其中，默认的策略为noeviction策略，当内存使用达到阈值的时候，所有引起申请内存的命令会报错

```xml
allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
	适合的场景： 如果我们的应用对缓存的访问都是相对热点数据，那么可以选择这个策略

allkeys-random：随机移除某个key。
	适合的场景：如果我们的应用对于缓存key的访问概率相等，则可以使用这个策略

volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰。

volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰。

volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
	适合场景：这种策略使得我们可以向Redis提示哪些key更适合被淘汰，我们可以自己控制
```



​	**注意**：实际上Redis实现的LRU并不是可靠的LRU，也就是名义上我们使用LRU算法淘汰内存数据，但是实际上被淘汰的键并不一定是真正的最少使用的数据，这里涉及到一个权衡的问题，如果需要在所有的数据中搜索最符合条件的数据，那么一定会增加系统的开销，Redis是单线程的，所以耗时的操作会谨慎一些。为了在一定成本内实现相对的LRU，早期的Redis版本是基于采样的LRU，也就是放弃了从所有数据中搜索解改为采样空间搜索最优解。Redis3.0版本之后，Redis作者对于基于采样的LRU进行了一些优化，目的是在一定的成本内让结果更靠近真实的LRU。



# 5. Redis为什么是单线程的？性能为什么那么快

## 5.1 redis为什么是单线程?

​	单线程来处理来自所有客户端的并发请求，Redis把任务封闭在一个线程中从而**避免了线程安全问题**	

```xml
    官方的解释是: CPU并不是Redis的瓶颈所在，Redis的瓶颈主要在 机器的内存 和 网络的带宽。那么Redis能不能处理高并发请求呢？当然是可以的，至于怎么实现的，我们来具体了解一下。 【注意并发不等于并行，并发性I/O流，意味着能够让一个计算单元来处理来自多个客户端的流请求。并行性，意味着服务器能够同时执行几个事情，具有多个计算单元
```

## 5.2 性能为什么那么快

​      基于内存存储数据的；IO多路复用的；

​	Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，而 I/O 多路复用就是为了解决这个问题而出现的



# 6. Lua脚本

​     Lua是一个高效的轻量级脚本语言(javascript、shell、sql、python、ruby…)，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能;

**Redis存在的问题：**

- 原子性问题
  - Redis作为数据服务器，是提供给多个客户端使用的。多个客户端的操作就相当于同一个进程下的多个线程，如果多个客户端之间没有做好数据的同步策略，就会产生数据不一致的问题

- 效率问题
  - redis本身的吞吐量是非常高的，因为它首先是基于内存的数据库。在实际使用过程中，有一个非常重要的因素影响redis的吞吐量，那就是网络



​     Redis中内嵌了对Lua环境的支持，允许开发者使用Lua语言编写脚本传到Redis中执行，Redis客户端可以使用Lua脚本，直接在服务端原子的执行多个Redis命令。



**使用脚本的好处：**

- 减少网络开销，在Lua脚本中可以把多个命令放在同一个脚本中运行

- 原子操作，redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。换句话说，编写脚本的过程中无需担心会出现竞态条件

- 复用性，客户端发送的脚本会永远存储在redis中，这意味着其他客户端可以复用这一脚本来完成同样的逻辑



# 7.事务

## 7.1. MULTI

​	用于标记事务块的开始。Redis会将后续的命令逐个放入队列中，然后才能使用EXEC命令原子化地执行这个命令序列。这个命令的运行格式如下所示：

```MULTI				这个命令的返回值是一个简单的字符串，总是OK。```



## 7.2. EXEC

在一个事务中执行所有先前放入队列的命令，然后恢复正常的连接状态。

​	当使用WATCH命令时，只有当受监控的键没有被修改时，EXEC命令才会执行事务中的命令，这种方式利用了检查再设置（CAS）的机制。这个命令的运行格式如下所示：

`EXEC`

​	这个命令的返回值是一个数组，其中的每个元素分别是原子化事务中的每个命令的返回值。 当使用WATCH命令时，如果事务执行中止，那么EXEC命令就会返回一个Null值。

## 7.3. DISCARD

清除所有先前在一个事务中放入队列的命令，然后恢复正常的连接状态。

​	如果使用了WATCH命令，那么DISCARD命令就会将当前连接监控的所有键取消监控。这个命令的运行格式如下所示：

`DISCARD`

这个命令的返回值是一个简单的字符串，总是OK;DISCARD命令可以用来中止事务运行。在这种情况下，不会执行事务中的任何命令，并且会将Redis连接恢复为正常状态。

![](http://ww1.sinaimg.cn/large/b8a27c2fgy1g1ttzyaxn2j206n056myi.jpg)

## 7.4. WATCH

​	当某个事务需要按条件执行时，就要使用这个命令将给定的键设置为受监控的。这个命令的运行格式如下所示：

`WATCH key [key ...]`

这个命令的返回值是一个简单的字符串，总是OK。对于每个键来说，时间复杂度总是O(1)



​	那么WATCH命令实际做了些什么呢？这个命令会使得EXEC命令在满足某些条件时才会运行事务：我们要求Redis只有在所有受监控的键都没有被修改时，才会执行事务。（但是，相同的客户端可能会在事务内部修改这些键，此时这个事务不会中止运行。）否则，Redis根本就不会进入事务。（注意，如果你使用WATCH命令监控一个易失性的键，然后在你监控这个键之后，Redis再使这个键过期，那么EXEC命令仍然可以正常工作。）



​	WATCH命令可以被调用多次。简单说来，所有的WATCH命令都会在被调用之时立刻对相应的键进行监控，直到EXEC命令被调用之时为止。你可以在单条的WATCH命令之中，使用任意数量的键作为命令参数。

​	当调用EXEC命令时，所有的键都会变为未受监控的状态，Redis不会管事务是否被中止。当一个客户单连接被关闭时，所有的键也都会变为未受监控的状态。



## 7.5. UNWATCH

​	清除所有先前为一个事务监控的键。如果你调用了EXEC或DISCARD命令，那么就不需要手动调用UNWATCH命令。这个命令的运行格式如下所示：

​	`UNWATCH`

这个命令的返回值是一个简单的字符串，总是OK。时间复杂度总是O(1)。

​    

## 7.6事务执行中的问题

- 1>:如果在加入队列的时候(语法错误，返回的不是queue),会返回错误，并且这个事务会被丢弃

- 2>:如果在加入队列没有发生错误，在运行期间发生错误了，那么该事务任然会执行，把返回其中的错误情况，并且redis不支持回滚



## 7.7通过CAS操作实现乐观锁

​	Redis使用WATCH命令实现事务的“检查再设置”（CAS=check and save）行为。

​	作为WATCH命令的参数的键会受到Redis的监控，Redis能够检测到它们的变化。在执行EXEC命令之前，如果Redis检测到至少有一个键被修改了，那么整个事务便会中止运行，然后EXEC命令会返回一个Null值，提醒用户事务运行失败。



例如，设想我们需要将某个键的值自动递增1（假设Redis没有INCR命令）;首次尝试的伪码可能如下所示：

```java
val = GET mykey
val = val + 1
SET mykey $val
```

​	如果我们只有一个Redis客户端在一段指定的时间之内执行上述伪码的操作，那么这段伪码将能够可靠的工作。如果有多个客户端大约在同一时间尝试递增这个键的值，那么将会产生竞争状态。例如，客户端-A和客户端-B都会读取这个键的旧值（例如：10）。这两个客户端都会将这个键的值递增至11，最后使用SET命令将这个键的新值设置为11。因此，这个键的最终值是11，而不是12。

现在，我们可以使用WATCH命令完美地解决上述的问题，伪码如下所示：

```java
WATCH mykey
val = GET mykey
val = val + 1
MULTI
SET mykey $val
EXEC
```

​	由上述伪码可知，如果存在竞争状态，并且有另一个客户端在我们调用WATCH命令和EXEC命令之间的时间内修改了val变量的结果，那么事务将会运行失败。

​	我们只需要重复执行上述伪码的操作，希望此次运行不会再出现竞争状态。这种形式的锁就被称为乐观锁，它是一种非常强大的锁。在许多用例中，多个客户端可能会访问不同的键，因此不太可能发生冲突 —— 也就是说，通常没有必要重复执行上述伪码的操作

## 7.8 通过lua脚本实现事务

​	根据定义，Redis的rua脚本也是事务型的。因此，你可以通过Redis事务实现的功能，同样也可以通过Redis脚本来实现，而且通常脚本更简单、更快速。

​	由于Redis从2.6版本才开始引入脚本特性，而事务特性是很久以前就已经存在的，所以目前的版本才有两个看起来重复的特性。但是，我们不太可能在短时间内移除对事务特性的支持。因为，即使不用求助于Redis脚本，用户仍然能够规避竞争状态，这从语义上来看是适宜的。还有另一个更重要的原因，Redis事务特性的实现复杂度是最小的