# 一、服务器中的数据库

​		redis服务器的数据库保存在一个bd数组中，定义如下

```c
struct redisServer{
    ...
    redisDb *db; //保存着服务器中所有的数据库,默认是16个
    ...    

}
typedef struct redisBd{
    ...
    dict * dict; //数据库键空间，保存了数据库中的所有键值对，字典数据结构
    //。。。
}
```



## 1. 切换数据库

```bash
redis>select 1 
//选择一号库
```

## 2 .Redis过期时间

​	原理：redis底层都是使用一个字典结构保存了所有键的过期时间，这个字典被称为过期字典

```c
typedef struct redisDb{
    ...
    dict * dict; //数据库键空间，保存了数据库中的所有键值对，字典数据结构
    dict * expires; //保存了键的过期时间
}
```

​	另外redis保存的过期时间是未来某个过期的时间戳，即设置的时候的当前时间+过期时间

### 2.1 命令使用

> 1）`EXPIRE key seconds`: 设置过期时间

 	其中seconds 参数表示键的过期时间，**单位为秒**。
​	EXPIRE 返回值为1表示设置成功，0表示设置失败或者键不存在

如果需要精确控制时间，可以使用`PEXPIRE` :单位是毫秒



> 2）`TTL key`：查看过期时间还剩多少
>
> 当键不存在时，TTL命令会返回-2
> 而对于没有给指定键设置过期时间的，通过TTL命令会返回-1



> 3）`setex(String key,int seconds,String value)`:针对字符串独有的过期时间设置



> 4）`PERSIST key `:该键恢复成为永久的，即解除过期

### 1.2  过期删除的原理

​    Redis 中的主键失效是如何实现的，即失效的主键是如何删除的？实际上，Redis 删除失效主键的方法主要有两
种。

#### 1） 消极方法（passive way）

​	也称惰性删除，在主键被访问时如果发现它已经失效，那么就删除它，缺点是如果久了不访问，会占用大量的内存，我们也称为内存泄露，所以需要积极的删除方法。

#### 2）积极方法（active way）

​	周期性地从设置了失效时间的主键中选择一部分失效的主键删除；这样可以只是删除部分，避免大量删除占用CPU的时间对正常的请求造成影响。

​       对于那些从未被查询的key，即便它们已经过期，消极方式也无法清除。因此Redis会周期性地随机测试一些key，已过期的key将会被删掉。Redis每秒会进行10次操作，具体的流程：

- a:随机测试 20 个带有timeout信息的key；
- b:删除其中已经过期的key；
- c:如果超过25%的key被删除，则重复执行步骤a；

​      这是一个简单的概率算法（trivial probabilistic algorithm），基于假设我们随机抽取的key代表了全部的key空
间。



## 3. 持久化

​		Redis支持两种方式的持久化，一种是RDB方式、另一种是AOF（append-only-file）方式。两种持久化方式可以单独使用其中一种，也可以将这两种方式结合使用。

- RDB会根据指定的规则“定时”将内存中的数据存储在硬盘上；（默认使用）

- AOF后者在每次执行命令后将命令本身记录下来。(需要打开设置)

  ​	

  ​	当redis启动的时候如果开启了AOF就模拟一个伪客户端执行AOF中的命令恢复数据，如果没有开启AOF就会加重RDB文件进行数据加载。

  

### 3.1 RDB

   	  当符合一定条件时，Redis会单独创建（fork）一个子进程来进行持久化，会先将数据写入到一个**临时文件**中，等到持久化过程都结束了，再用这个**临时文件替换上次持久化好的文件**。整个过程中，主进程是不进行任何IO操作的，这就确保了极高的性能。如果需要进行大规模数据的恢复，且对于数据恢复的完整性不是非常敏感，那RDB方式要比AOF方式更加的高效。

​	RDB文件是一个经过压缩的二进制文件。

**1）RDB的缺点：**是最后一次持久化后的数据可能丢失;

​       fork的作用是复制一个与当前进程一样的进程。新进程的所有数据（变量、环境变量、程序计数器等）数值都和原进程一致，但是是一个全新的进程，并作为原进程的子进程。



**2）Redis会在以下几种情况下对数据进行快照：**

- a: 根据配置规则进行自动快照；见`3）`下面操作
- b: 用户执行SAVE或者GBSAVE命令
  - SAVE是阻塞的，通过命令方式完成快照会阻塞其他客户端请求，生产上不建议使用
  - GBSAVE:可以在后台异步地进行快照操作，快照的同时服务器还可以继续响应来自客户端的请求
- c: 执行FLUSHALL命令
  - 会清除redis在内存中的所有数据。执行该命令后，只要redis中配置的快照规则不为空，redis就会执行一次快照操作，不管规则是什么样的都会执行。如果没有定义快照规则，就不会执行快照操作

- d: 执行复制(replication)时
  - 该操作主要是在主从模式下，redis会在复制初始化时进行自动快照。



**3）根据配置规则进行自动快照**

​	Redis允许用户自定义快照条件,在配置文件中配置：

```xml
配置格式如下:
save param01 param02 
   第一个参数是时间窗口(单位秒)，第二个是键的个数，也就是说，在第一个时间参数配置范围内被更改的键的个数大于后面的changes时，即符合快照条件。redis默认配置了三个规则:
save 900 1
save 300 10
save 60 10000
每条快照规则占一行，每条规则之间是“或”的关系。 在900秒（15分）内有一个以上的键被更改则进行快照。
```



### 3.2 AOF(appendonly file)

​         当使用Redis存储非临时数据时，一般需要打开AOF持久化来降低进程终止导致的数据丢失。AOF可以将Redis执行的每一条写命令追加到硬盘文件中，这一过程会降低Redis的性能，但大部分情况下这个影响是能够接受的，另外使用较快的硬盘可以提高AOF的性能。相比RDB数据丢失风险更小，甚至没有

**1）开启AOP持久化模式**

​      默认情况下Redis没有开启AOF（append only file）方式的持久化，可以通过appendonly参数启用，在redis.conf中找到 `appendonly yes`

```java
相关解释：
      \#只要有一个key发生改变那么立马和后台同步  这种模式不会丢数据但是  效率不高  一般不推荐
      \# appendfsync always

      \# 这个表示每秒钟和硬盘同步一次，官方推荐这种模式
      appendfsync everysec

      \# 这个和内存的缓冲区有关 缓冲区满了自动同步  没满的话那么就只有等
      \# appendfsync no
```



​    开启AOF持久化后每执行一条会更改Redis中的数据的命令后，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是apendonly.aof. 可以在redis.conf中的属性 appendfilename appendonlyh.aof修改

```xml
执行命令：
set foo 1
set foo 2
set foo 3
get      

    我们会发现AOF文件的内容正是Redis发送的原始通信协议的内容，从内容中我们发现Redis只记录了3条命令。然后这时有一个问题是前面2条命令其实是冗余的，因为这两条的执行结果都会被第三条命令覆盖。随着执行的命令越来越多，AOF文件的大小也会越来越大，其实内存中实际的数据可能没有多少，那这样就会造成磁盘空间以及redis数据还原的过程比较长的问题。因此我们希望Redis可以自动优化AOF文件，就上面这个例子来说，前面两条是可以被删除的。 

而实际上Redis也考虑到了，可以配置一个条件，每当达到一定条件时Redis就会自动重写AOF文件，这个条件的配置为：
auto-aof-rewrite-percentage 100 
auto-aof-rewrite-min-size 64mb

auto-aof-rewrite-percentage 表示的是当目前的AOF文件大小超过上一次重写时的AOF文件大小的百分之多少时会再次进行重写，如果之前没有重写过，则以启动时AOF文件大小为依据

auto-aof-rewrite-min-size 表示限制了允许重写的最小AOF文件大小，通常在AOF文件很小的情况下即使其中有很多冗余的命令我们也并不太关心

还可以通过BGREWRITEAOF 命令手动执行AOF，执行完以后冗余的命令已经被删除了
```



**2）AOF的重写原理**

​     Redis 可以在 AOF 文件体积变得过大时，自动地在后台对 AOF 进行重写： 重写后的新 AOF 文件包含了恢复当前数据集所需的最小命令集合。

​       重写的流程是这样，主进程会fork一个子进程出来进行AOF重写，这个重写过程并不是基于原有的aof文件来做的，而是首先从数据库中读取键现在的值，然后用一条命令去记录键值对，代替之前记录这个键值对的多条命令，然后存储到aof文件中。如果一个键（例如set，hashtable）的数据过大会分成几个命令存储，

​       在fork子进程这个过程中，服务端仍然可以对外提供服务，那这个时候重写的aof文件的数据和redis内存数据不一致了怎么办？不用担心，这个过程中，主进程的数据更新操作，会缓存到aof_rewrite_buf中，也就是单独开辟一块缓存来存储重写期间收到的命令，当子进程重写完以后再把缓存中的数据追加到新的aof文件。当所有的数据全部追加到新的aof文件中后，把新的aof文件重命名为，此后所有的操作都会被写入新的aof文件。如果在rewrite过程中出现故障，不会影响原来aof文件的正常工作，只有当rewrite完成后才会切换文件。因此这个rewrite过程是比较可靠的。



## 4.Redis内存回收策略

​    Redis中提供了多种内存回收策略，当内存容量不足时，为了保证程序的运行，这时就不得不淘汰内存中的一些对象，释放这些对象占用的空间，那么选择淘汰哪些对象呢？

其中，默认的策略为noeviction策略，当内存使用达到阈值的时候，所有引起申请内存的命令会报错

```xml
allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰
	适合的场景： 如果我们的应用对缓存的访问都是相对热点数据，那么可以选择这个策略

allkeys-random：随机移除某个key。
	适合的场景：如果我们的应用对于缓存key的访问概率相等，则可以使用这个策略

volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰。

volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰。

volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰
	适合场景：这种策略使得我们可以向Redis提示哪些key更适合被淘汰，我们可以自己控制
```



​	**注意**：实际上Redis实现的LRU并不是可靠的LRU，也就是名义上我们使用LRU算法淘汰内存数据，但是实际上被淘汰的键并不一定是真正的最少使用的数据，这里涉及到一个权衡的问题，如果需要在所有的数据中搜索最符合条件的数据，那么一定会增加系统的开销，Redis是单线程的，所以耗时的操作会谨慎一些。为了在一定成本内实现相对的LRU，早期的Redis版本是基于采样的LRU，也就是放弃了从所有数据中搜索解改为采样空间搜索最优解。Redis3.0版本之后，Redis作者对于基于采样的LRU进行了一些优化，目的是在一定的成本内让结果更靠近真实的LRU。



## 5.发布订阅

​      Redis提供了发布订阅功能，可以用于消息的传输，Redis提供了一组命令可以让开发者实现“发布/订阅”模式(publish/subscribe) . 该模式同样可以实现进程间的消息传递，它的实现原理是：

​     发布/订阅模式包含两种角色，分别是发布者和订阅者。订阅者可以订阅一个或多个频道，而发布者可以向指定的频道发送消息，所有订阅此频道的订阅者都会收到该消息；

> 发布者发布消息的命令是PUBLISH， 用法是`PUBLISH channel message`
>
> 比如向channel.1发一条消息:hello
> ​	`PUBLISH channel.1 “hello”`



​    这样就实现了消息的发送，该命令的返回值表示接收到这条消息的订阅者数量。因为在执行这条命令的时候还没有订阅者订阅该频道，所以返回为0. 另外值得注意的是**消息发送出去不会持久化**，如果发送之前没有订阅者，那么后续再有订阅者订阅该频道，之前的消息就收不到了.



> 订阅者订阅消息的命令是
> ​	SUBSCRIBE channel [channel …]
> 该命令同时可以订阅多个频道，比如订阅channel.1的频道。 SUBSCRIBE channel.1执行SUBSCRIBE命令后客户端会进入订阅状态



# 二、事件

​	Redis服务器是一个事件驱动程序，主要处理文件事件和时间事件两类事件。

## 1.文件事件

- 事件处理器使用I/O多路复用程序，根据套接字目前执行的任务来为套接字关联不同的事件处理器
- 被监听的套接字准备好执行连接应答，读取，写入，关闭等操作，与操作相对应的文件事件就会产生，这是文件事件处理器就会调用套接字之前关联的事件处理器来处理这些事件

这样就可以实现高性能的网络通信模型，又可以以单线程的方式与运行的模块堵截，保持redis设计的简单性

![微信图片_20190905210532.jpg](http://ww1.sinaimg.cn/mw690/b8a27c2fgy1g6oy1dj1xkj20gf0ce757.jpg)

​		有可能会并发有多个文件事件，那么I/O多路复用程序会将所有产生事件的套接字放到一个队列里面，然通过这个队列，以有序的，同步的每次一个套接字的方式向文件事件分派器传送套接字，当上一个套接字处理完毕后，才会发送下一个套接字。

## 2.时间事件

时间事件又分为两种：定时时间和周期性时间

主要是通过ServerCron函数来调用，服务器模式severCron每秒运行10次，每次间隔100ms运行一次。 



# 三、客户端

​	服务器状态结构使用clients链表连接起多个客户端状态，新添加的客户端状态会被放到链表的末尾。

❑客户端状态的flags属性使用不同标志来表示客户端的角色，以及客户端当前所处的状态。

❑输入缓冲区记录了客户端发送的命令请求，这个缓冲区的大小不能超过1GB。

❑命令的参数和参数个数会被记录在客户端状态的argv和argc属性里面，而cmd属性则记录了客户端要执行命令的实现函数。

❑客户端有固定大小缓冲区和可变大小缓冲区两种缓冲区可用，其中固定大小缓冲区的最大大小为16KB，而可变大小缓冲区的最大大小不能超过服务器设置的硬性限制值。

❑输出缓冲区限制值有两种，如果输出缓冲区的大小超过了服务器设置的硬性限制，那么客户端会被立即关闭；除此之外，如果客户端在一定时间内，一直超过服务器设置的软性限制，那么客户端也会被关闭。

❑当一个客户端通过网络连接连上服务器时，服务器会为这个客户端创建相应的客户端状态。网络连接关闭、发送了不合协议格式的命令请求、成为CLIENT KILL命令的目标、空转时间超时、输出缓冲区的大小超出限制，以上这些原因都会造成客户端被关闭。

❑处理Lua脚本的伪客户端在服务器初始化时创建，这个客户端会一直存在，直到服务器关闭。

❑载入AOF文件时使用的伪客户端在载入工作开始时动态创建，载入工作完毕之后关闭。



# 四、服务器

## 1.命令请求的执行过程

​		一个命令从发送到获得回复需要完成一系列操作。

### 1）发送命令请求

​	当客户端键入一个命令请求是，这个命令会被转换成协议格式，然后通过连接到服务器的套接字将协议格式的命令请求发送给服务器。



### 2）读取命令请求

​		当客户端与服务器之间的连接套接字因为客户端的写入而变得可读时，服务器将调用命令请求处理器来执行以下操作：

- 读取套接字中协议格式的命令请求，并将其保存到客户端状态的`输入缓冲区`里面。
- 对输入缓冲区中的命令请求进行分析，提取出命令请求中包含的命令参数，以及命令参数的个数，然后分别将参数和参数个数保存到客户端状态的argv属性和argc属性里面。
- 调用命令执行器，执行客户端指定的命令。



### 3）命令执行器：查找命令实现

​		命令执行器要做的第一件事就是根据客户端状态的argv[0]参数，在命令表（command table）中查找参数所指定的命令，并将找到的命令保存到客户端状态的cmd属性里面。

​		命令表是一个字典，字典的键是一个个命令名字，比如"set"、"get"、"del"等等；而字典的值则是一个个redisCommand结构，每个redisCommand结构记录了一个Redis命令的实现信息。



### 4）命令执行器：执行预备操作

​		到目前为止，服务器已经将执行命令所需的命令实现函数（保存在客户端状态的cmd属性）、参数（保存在客户端状态的argv属性）、参数个数（保存在客户端状态的argc属性）都收集齐了，但是在真正执行命令之前，程序还需要进行一些预备操作，从而确保命令可以正确、顺利地被执行，这些操作包括：

❑检查客户端状态的cmd指针是否指向NULL，如果是的话，那么说明用户输入的命令名字找不到相应的命令实现，服务器不再执行后续步骤，并向客户端返回一个错误。

❑根据客户端cmd属性指向的redisCommand结构的arity属性，检查命令请求所给定的参数个数是否正确，当参数个数不正确时，不再执行后续步骤，直接向客户端返回一个错误。比如说，如果redisCommand结构的arity属性的值为-3，那么用户输入的命令参数个数必须大于等于3个才行。

❑检查客户端是否已经通过了身份验证，未通过身份验证的客户端只能执行AUTH命令，如果未通过身份验证的客户端试图执行除AUTH命令之外的其他命令，那么服务器将向客户端返回一个错误。

❑如果服务器打开了maxmemory功能，那么在执行命令之前，先检查服务器的内存占用情况，并在有需要时进行内存回收，从而使得接下来的命令可以顺利执行。如果内存回收失败，那么不再执行后续步骤，向客户端返回一个错误。

❑如果服务器上一次执行BGSAVE命令时出错，并且服务器打开了stop-writes-on-bgsave-error功能，而且服务器即将要执行的命令是一个写命令，那么服务器将拒绝执行这个命令，并向客户端返回一个错误。

❑如果客户端当前正在用SUBSCRIBE命令订阅频道，或者正在用PSUBSCRIBE命令订阅模式，那么服务器只会执行客户端发来的SUBSCRIBE、PSUBSCRIBE、UNSUBSCRIBE、PUNSUBSCRIBE四个命令，其他命令都会被服务器拒绝。

❑如果服务器正在进行数据载入，那么客户端发送的命令必须带有l标识（比如INFO、SHUTDOWN、PUBLISH等等）才会被服务器执行，其他命令都会被服务器拒绝。

❑如果服务器因为执行Lua脚本而超时并进入阻塞状态，那么服务器只会执行客户端发来的SHUTDOWN nosave命令和SCRIPT KILL命令，其他命令都会被服务器拒绝。

❑如果客户端正在执行事务，那么服务器只会执行客户端发来的EXEC、DISCARD、MULTI、WATCH四个命令，其他命令都会被放进事务队列中。

❑如果服务器打开了监视器功能，那么服务器会将要执行的命令和参数等信息发送给监视器。当完成了以上预备操作之后，服务器就可以开始真正执行命令了。	



### 5）命令执行器：调用

​	在之前的操作中执行命令中已经保存了客户端状态的cmd属性里面，命令的参数和个数也保存了，这个时候直接调用对应的函数执行即可，相应的这些命令的恢复也会被保存在客户端的输出缓冲中，



### 6）命令执行器：执行后续工作

​		执行完实现函数之后，服务器还需要执行一些后续工作：

❑如果服务器开启了慢查询日志功能，那么慢查询日志模块会检查是否需要为刚刚执行完的命令请求添加一条新的慢查询日志。

❑根据刚刚执行命令所耗费的时长，更新被执行命令的redisCommand结构的milliseconds属性，并将命令的redisCommand结构的calls计数器的值增一。

❑如果服务器开启了AOF持久化功能，那么AOF持久化模块会将刚刚执行的命令请求写入到AOF缓冲区里面。

❑如果有其他从服务器正在复制当前这个服务器，那么服务器会将刚刚执行的命令传播给所有从服务器。

​		当以上操作都执行完了之后，服务器对于当前命令的执行到此就告一段落了，之后服务器就可以继续从文件事件处理器中取出并处理下一个命令请求了。

### 7）将命令回复发送给客户端
​		前面说过，命令实现函数会将命令回复保存到客户端的输出缓冲区里面，并为客户端的套接字关联命令回复处理器，当客户端套接字变为可写状态时，服务器就会执行命令回复处理器，将保存在客户端输出缓冲区中的命令回复发送给客户端。

当命令回复发送完毕之后，回复处理器会清空客户端状态的输出缓冲区，为处理下一个命令请求做好准备。


### 8）客户端接收并打印命令回复
​		当客户端接收到协议格式的命令回复之后，它会将这些回复转换成人类可读的格式，并打印给用户观看（假设我们使用的是Redis自带的redis-cli客户端）



## 2. serverCron函数

​		这个函数默认100毫秒执行一次，负责保持服务器的良好运作

Redis服务器中有不少功能需要获取系统的当前时间，而每次获取系统的当前时间都需要执行一次系统调用，为了减少系统调用的执行次数，服务器状态中的unixtime属性和mstime属性被用作当前时间的缓存：
￼

```c
struct redisServer {￼
      // ...￼
      //保存了秒级精度的系统当前UNIX时间戳￼
      time_t unixtime;￼
      //保存了毫秒级精度的系统当前UNIX时间戳￼
      long long mstime;￼
      // ...￼
};
```

​		因为serverCron函数默认会以每100毫秒一次的频率更新unixtime属性和mstime属性，所以这两个属性记录的时间的精确度并不高：

❑服务器只会在打印日志、更新服务器的LRU时钟、决定是否执行持久化任务、计算服务器上线时间（uptime）这类对时间精确度要求不高的功能上。

❑对于为键设置过期时间、添加慢查询日志这种需要高精确度时间的功能来说，服务器还是会再次执行系统调用，从而获得最准确的系统当前时间。



## 3. 服务器初始化

​		服务器从启动到能够处理客户端的命令请求需要执行以下步骤：

1）初始化服务器状态；

2）载入服务器配置；

3）初始化服务器数据结构；

4）还原数据库状态；

5）执行事件循环。



# 5. Redis为什么是单线程的？性能为什么那么快

## 5.1 redis为什么是单线程?

​	单线程来处理来自所有客户端的并发请求，Redis把任务封闭在一个线程中从而**避免了线程安全问题**	

```xml
    官方的解释是: CPU并不是Redis的瓶颈所在，Redis的瓶颈主要在 机器的内存 和 网络的带宽。那么Redis能不能处理高并发请求呢？当然是可以的，至于怎么实现的，我们来具体了解一下。 【注意并发不等于并行，并发性I/O流，意味着能够让一个计算单元来处理来自多个客户端的流请求。并行性，意味着服务器能够同时执行几个事情，具有多个计算单元，
```

​	redis自带redisbench工具可以测试硬件的qps

## 5.2 性能为什么那么快

- 基于内存存储数据的；
- IO多路复用的；
- redis底层数据结构（个人认为，不同的数据结果增加数据的crud性能）
- 单线程操作，在一定情况避免内核和用户空间切换（这个也是在线程操作CPU核数的情况才可能）

​		Redis 是跑在单线程中的，所有的操作都是按照顺序线性执行的，但是由于读写操作等待用户输入或输出都是阻塞的，所以 I/O 操作在一般情况下往往不能直接返回，这会导致某一文件的 I/O 阻塞导致整个进程无法对其它客户提供服务，尤其是网络差的时候；

​		 而 I/O 多路复用就是为了解决这个问题而出现的，当客户端不同的请求就采用不同的事件处理器去处理，避免站着茅坑不拉屎，等你半天才响应；当你数据还没有来的时候（网络差的时候）先给你注册一个可读事件，然后处理其他请求，当你的读请求来了才过来处理你的请求，避免你发送数据一致阻塞，其他客户端没有办法连接的情况。



# 6. Lua脚本

​     Lua是一个高效的轻量级脚本语言(javascript、shell、sql、python、ruby…)，用标准C语言编写并以源代码形式开放， 其设计目的是为了嵌入应用程序中，从而为应用程序提供灵活的扩展和定制功能;

## 6.1 Lua脚本介绍

**Redis存在的问题：**

- 原子性问题
  - Redis作为数据服务器，是提供给多个客户端使用的。多个客户端的操作就相当于同一个进程下的多个线程，如果多个客户端之间没有做好数据的同步策略，就会产生数据不一致的问题

- 效率问题
  - redis本身的吞吐量是非常高的，因为它首先是基于内存的数据库。在实际使用过程中，有一个非常重要的因素影响redis的吞吐量，那就是网络



​     Redis中内嵌了对Lua环境的支持，允许开发者使用Lua语言编写脚本传到Redis中执行，Redis客户端可以使用Lua脚本，直接在服务端原子的执行多个Redis命令。



**使用脚本的好处：**

- 减少网络开销，在Lua脚本中可以把多个命令放在同一个脚本中运行

- 原子操作，redis会将整个脚本作为一个整体执行，中间不会被其他命令插入。换句话说，编写脚本的过程中无需担心会出现竞态条件

- 复用性，客户端发送的脚本会永远存储在redis中，这意味着其他客户端可以复用这一脚本来完成同样的逻辑

## 6.2 Lua使用

​	命令使用

| 序号 | 命令                                             | 描述                                                         |
| ---- | ------------------------------------------------ | ------------------------------------------------------------ |
| 1    | EVAL script numkeys key [key ...] arg [arg ...]  | 执行 Lua 脚本                                                |
| 2    | EVALSHA sha1 numkeys key [key ...] arg [arg ...] | 执行 Lua 脚本,通过脚本的sha值执行该脚本                      |
| 3    | SCRIPT EXISTS sha1 [sha1...]                     | 查看指定的脚本是否已经被保存在缓存当中，这里的script传递的是sha1值 |
| 4    | SCRIPT FLUSH                                     | 从脚本缓存中移除所有脚本                                     |
| 5    | SCRIPT KILL                                      | 杀死当前正在运行的 Lua 脚本                                  |
| 6    | SCRIPT LOAD script                               | 将脚本 script 添加到脚本缓存中，但并不立即执行这个脚本，返回当前脚本的sha1值evalsha可以通过这个值调该脚本 |

```bash
#例子，下面的2表示有两个KEYS，下注从1开始，ARGV下标也是从1开始计算
redis:6379>EVAL "return redis.call('mset',KEYS[1],KEYS[2],ARGV[1],ARGV[2])" 2 vison 1 jack 2 

#通过evalsha执行脚本信息
redis:6379>EVALSHA 49031ffd486a9b8ca9d87fb5027214da2fca027c 2 vison 1 jack 2 

-------------下面就是属于脚本的管理了---------------------

#判定单签的脚本是否存在
redis:6379>SCRIPT EXISTS 49031ffd486a9b8ca9d87fb5027214da2fca027c
1) 1

#清空redis服务器中缓存的所有脚本信息
redis:6379>SCRIPT FLUSH
ok

#关闭当前正在执行的redis脚本
redis:6379>SCRIPT KILL
ok

# 会返回当前脚本的sha1值，这个脚本会保存在redis服务器中，下次通过evalsha 直接调用sha1值即可
redis:6379>SCRIPT LOAD "return redis.call('mset',KEYS[1],KEYS[2],ARGV[1],ARGV[2])"
`49031ffd486a9b8ca9d87fb5027214da2fca027c`
```



```bash
Redis执行lua脚本主要依靠两个命令：EVAL和EVALSHA

EVAL 命令要求你在每次执行脚本的时候都发送一次脚本主体(script body)。Redis 有一个内部的缓存机制，因此它不会每次都重新编译脚本，不过在很多场合，付出无谓的带宽来传送脚本主体并不是最佳选择。

为了减少带宽的消耗， Redis 实现了 EVALSHA命令，它的作用和 EVAL 一样，都用于对脚本求值，但它接受的第一个参数不是脚本，而是脚本的 SHA1 散列值。

EVAL的第一个参数是一段 Lua脚本程序。 这段Lua脚本不需要（也不应该）定义函数。它运行在 Redis 服务器中。

EVAL的第二个参数是参数的个数，后面的参数（从第三个参数），表示在脚本中所用到的那些 Redis 键(key)，这些键名参数可以在 Lua 中通过全局变量 KEYS 数组，用 1 为基址的形式访问( KEYS[1] ， KEYS[2] ，以此类推)。

在命令的最后，那些不是键名参数的附加参数 arg [arg …] ，可以在 Lua 中通过全局变量 ARGV 数组访问，访问的形式和 KEYS 变量类似( ARGV[1] 、 ARGV[2] ，以此类推)。

Redis在lua脚本中提供了两个方法用来执行任意Redis命令：redis.call()和redis.pcall()，两者的区别是出错时前者直接报错，后者会捕获错误并返回错误信息。

```



## 5.3 Lua脚本原理

**1）执行过程**

- 在Redis服务器创建Lua环境，包含加载一些Lua脚本函数，

- 执行脚本时，Lua环境将命令传递给伪客户端执行->然后命令执行器执行，依次返回给Lua环境

![n6XoJf.jpg](https://s2.ax1x.com/2019/09/14/n6XoJf.jpg)



**2）存储原理**

​		Redis服务器为Lua环境创建一个lua_scripts字典，这个字典的键是某一个Lua脚本的SHA1的校验和（40个字符长），值就是Lua脚本信息。所有被EVAL执行过的命令以及所以被SCRIPT LOAD命令载入过的Lua脚本都会被保存到lua_scripts字典中。这个字典可以实现script exists命令，另外一个就是复制功能（让主从服务器保存相同的脚本要依赖另外一个字典了）

​	管理script其实就是管理这个lua_script字典信息

**3）EVAL命令的实现**	

VAL命令的执行过程可以分为以下三个步骤：
1）根据客户端给定的Lua脚本，在Lua环境中定义一个Lua函数（f_sha1）。
2）将客户端给定的脚本保存到lua_scripts字典，等待将来进一步使用。
3）执行刚刚在Lua环境中定义的函数，以此来执行客户端给定的Lua脚本



# 7.事务

## 7.1. MULTI

​	用于标记事务块的开始。Redis会将后续的命令逐个放入队列中，然后才能使用EXEC命令原子化地执行这个命令序列。这个命令的运行格式如下所示：

```MULTI				这个命令的返回值是一个简单的字符串，总是OK。```



## 7.2. EXEC

在一个事务中执行所有先前放入队列的命令，然后恢复正常的连接状态。

​	当使用WATCH命令时，只有当受监控的键没有被修改时，EXEC命令才会执行事务中的命令，这种方式利用了检查再设置（CAS）的机制。这个命令的运行格式如下所示：

`EXEC`

​	这个命令的返回值是一个数组，其中的每个元素分别是原子化事务中的每个命令的返回值。 当使用WATCH命令时，如果事务执行中止，那么EXEC命令就会返回一个Null值。

## 7.3. DISCARD

清除所有先前在一个事务中放入队列的命令，然后恢复正常的连接状态。

​	如果使用了WATCH命令，那么DISCARD命令就会将当前连接监控的所有键取消监控。这个命令的运行格式如下所示：

`DISCARD`

这个命令的返回值是一个简单的字符串，总是OK;DISCARD命令可以用来中止事务运行。在这种情况下，不会执行事务中的任何命令，并且会将Redis连接恢复为正常状态。

![](http://ww1.sinaimg.cn/large/b8a27c2fgy1g1ttzyaxn2j206n056myi.jpg)

## 7.4. WATCH

​	当某个事务需要按条件执行时，就要使用这个命令将给定的键设置为受监控的。这个命令的运行格式如下所示：

`WATCH key [key ...]`

这个命令的返回值是一个简单的字符串，总是OK。对于每个键来说，时间复杂度总是O(1)



​	那么WATCH命令实际做了些什么呢？这个命令会使得EXEC命令在满足某些条件时才会运行事务：我们要求Redis只有在所有受监控的键都没有被修改时，才会执行事务。（但是，相同的客户端可能会在事务内部修改这些键，此时这个事务不会中止运行。）否则，Redis根本就不会进入事务。（注意，如果你使用WATCH命令监控一个易失性的键，然后在你监控这个键之后，Redis再使这个键过期，那么EXEC命令仍然可以正常工作。）



​	WATCH命令可以被调用多次。简单说来，所有的WATCH命令都会在被调用之时立刻对相应的键进行监控，直到EXEC命令被调用之时为止。你可以在单条的WATCH命令之中，使用任意数量的键作为命令参数。

​	当调用EXEC命令时，所有的键都会变为未受监控的状态，Redis不会管事务是否被中止。当一个客户单连接被关闭时，所有的键也都会变为未受监控的状态。



## 7.5. UNWATCH

​	清除所有先前为一个事务监控的键。如果你调用了EXEC或DISCARD命令，那么就不需要手动调用UNWATCH命令。这个命令的运行格式如下所示：

​	`UNWATCH`

这个命令的返回值是一个简单的字符串，总是OK。时间复杂度总是O(1)。

​    

## 7.6事务执行中的问题

- 1>:如果在加入队列的时候(语法错误，返回的不是queue),会返回错误，并且这个事务会被丢弃

- 2>:如果在加入队列没有发生错误，在运行期间发生错误了，那么该事务任然会执行，把返回其中的错误情况，并且redis不支持回滚



## 7.7通过CAS操作实现乐观锁

​	Redis使用WATCH命令实现事务的“检查再设置”（CAS=check and save）行为。

​	作为WATCH命令的参数的键会受到Redis的监控，Redis能够检测到它们的变化。在执行EXEC命令之前，如果Redis检测到至少有一个键被修改了，那么整个事务便会中止运行，然后EXEC命令会返回一个Null值，提醒用户事务运行失败。



例如，设想我们需要将某个键的值自动递增1（假设Redis没有INCR命令）;首次尝试的伪码可能如下所示：

```java
val = GET mykey
val = val + 1
SET mykey $val
```

​	如果我们只有一个Redis客户端在一段指定的时间之内执行上述伪码的操作，那么这段伪码将能够可靠的工作。如果有多个客户端大约在同一时间尝试递增这个键的值，那么将会产生竞争状态。例如，客户端-A和客户端-B都会读取这个键的旧值（例如：10）。这两个客户端都会将这个键的值递增至11，最后使用SET命令将这个键的新值设置为11。因此，这个键的最终值是11，而不是12。

现在，我们可以使用WATCH命令完美地解决上述的问题，伪码如下所示：

```java
WATCH mykey
val = GET mykey
val = val + 1
MULTI
SET mykey $val
EXEC
```

​	由上述伪码可知，如果存在竞争状态，并且有另一个客户端在我们调用WATCH命令和EXEC命令之间的时间内修改了val变量的结果，那么事务将会运行失败。

​	我们只需要重复执行上述伪码的操作，希望此次运行不会再出现竞争状态。这种形式的锁就被称为乐观锁，它是一种非常强大的锁。在许多用例中，多个客户端可能会访问不同的键，因此不太可能发生冲突 —— 也就是说，通常没有必要重复执行上述伪码的操作

## 7.8 通过lua脚本实现事务

​	根据定义，Redis的rua脚本也是事务型的。因此，你可以通过Redis事务实现的功能，同样也可以通过Redis脚本来实现，而且通常脚本更简单、更快速。

​	由于Redis从2.6版本才开始引入脚本特性，而事务特性是很久以前就已经存在的，所以目前的版本才有两个看起来重复的特性。但是，我们不太可能在短时间内移除对事务特性的支持。因为，即使不用求助于Redis脚本，用户仍然能够规避竞争状态，这从语义上来看是适宜的。还有另一个更重要的原因，Redis事务特性的实现复杂度是最小的