



# 1. 2pc 提交（two -phaseCommit 

​	2pc 提交属于强一致性

## 1.1 第一阶段

1.事务询问;

​	TM 向所有的 AP 发送事务内容，询问是否可以执行事务提交操作，并开始等待各AP的相应

2.执行事务

​	各个 AP 节点执行事务操作，并将 Undo 和 Redo 信息记录到事务日志中，尽量把提交过程中所有消耗时间的操作和准备都提前完成确保后面 100%成功提交事务

3.各个 AP 向 TM 反馈事务询问的响应
​	如果各个 AP 成功执行了事务操作，那么就反馈给 AP yes 的响应，表示事务可以执行；如果 AP 没有成功执行事务，就反馈给 TM no 的响应，表示事务不可以执行



​	上面这个阶段有点类似 TM 组织各个 AP 对一次事务操作的投票表态过程，因此2pc 协议的第一个阶段称为“投票阶段”，即各 AP 投票表名是否需要继续执行接下去的事务提交操作

## 1.2 第二阶段

1. 发送提交请求
   ​	TM 向所有 AP 节点发出 commit 请求

2. 事务提交
   ​	AP 接收到 Commit 请求后，会正式执行事务提交操作，并在完成提交之后释放在整个事务执行期间占用的事务资源

3. 反馈事务提交结果
   ​	AP 在完成事务提交之后，向 TM 发送 Ack 消息

4. 完成事务
   ​	TM 接收到所有 AP 反馈的 ack 消息后，完成事务

**事务回滚**
​	如果第一个阶段中的某一个资源预提交失败，那么第二个阶段就回滚第一阶段已经预提交成功的资源；假设任何一个 AP 向 TM 反馈了 NO 的响应，或者在等待超时之后，TM 无法接收到所有 AP 的反馈响应，那么就会中断事务

1. 发送回滚请求
   TM 向所有 AP 发出 abort 请求

2. 事务回滚
   AP 收到 abort 请求后，会利用在第一阶段记录的 Undo 信息来执行事务回滚操作，并在完成回滚之后释放在整个事务执行期间占用的资源

3. 反馈事务回滚结果
   各 AP 在完成事务回滚之后，向 TM 发送 Ack 消息

4. 中端事务
   TM接收到所有 AP 反馈的 ack 消息后，完成事务中断



Ø 二阶段提交将一个事务的处理过程分为投票和执行两个阶段 . 二阶段提交的优点在于，它充分考虑到了分布式系统的不可靠因素，并且采用非常简单的方式（两阶段提交）就把由于系统不可靠从而导致事务提交失败的概率降到最小
Ø 假如一个事务的提交过程总共需要 30 秒的操作，其中 prepare 阶段需要 28 秒（主要是确保事务日志落地磁盘等各种耗时的 I/O 操作），真正的 commit 阶段只需要花费两秒，那么 Commit 阶段发生错误的概率与 Prepare 阶段相比，只是它的2/28(<10%) ，也就是说，如果 Prepare 阶段成功了，则 Commit 阶段由于时间非常端，失败概率小，会大大增加分布式事务成功的概率。



## 1.3 2pc 协议的优缺点
1. 原理简单，实现很方便
2. 每一个阶段都是同步阻塞，会造成性能损耗。
3. 协调者存在单点问题，如果协调者在第二阶段出现故障，那么其他参与者会一直处于锁定状态。
4. 太过保守，任意一个节点失败都会导致数据回滚
5. 数据不一致问题: 在阶段二中，当协调者向所有的参与者发送 commit 请求后，发生了网络异常导致协调者在尚未发完 commit 请求之前崩溃，可能会导致只有部分的参与者接收到 commit 请求，剩没收到 commit 请求的参与者将无法提交事务，也就可能导致数据不一致的问题


# 2. 3pc 提交（three -phaseCommit） 

​	3PC 协议主要用来解决 2PC 的同步阻塞问题的一种优化方案，3pc 分为 3 个阶段
分别为：**cancommit、Precommit、doCommit。**

和 2 阶段提交的区别在于：

- (1) 在协调者和参与者中引入了超时机制，{2pc 只有在协调者拥有超时机制,协调者在一定时间内没受到参与者的信息则默认为失败}；
- (2) 把 2 阶段提交的第一个阶段拆分成了两个步骤。

## 2.1 cancommit 阶段
​	协调者向参与者发送 commit 请求，参与者如果可以提交就返回 yes 的响应，否则返回 No 的响应。这一阶段主要是确定分布式事务的参与者是否具备了完成commit 的条件，并不会执行事务操作。

- 询问参与者是否可以执行事务提交操作

- 正常情况下只要能够顺利执行事务，就返回 yes 的响应，并进入预备状态。

## 2.2  precommit 阶段

​	事务协调者根据参与者的反馈情况来决定是否继续执行事务的 precommit 操作，在这一个阶段，会有两种可能性，第一种是，在 cancommit 阶段所有参与者都反馈的是 yes，则会进行事务预执行
- 协调者向参与者发送 precommit 请求

- 参与者收到 precommit 请求后，执行事务操作，并把事务的 undo 和 redo 信息记录到事务日志中

- 返回事务的执行结果给到协调者，并等待最终的提交指令

如果任意一个事务参与者在第一阶段返回了 no，则执行事务中断请求

- 向所有事务参与者发送事务中断请求
- 对于事务参与者来说，无论是收到协调者的中断请求，还是等待协调者新的指



## 2.3 doCommit阶段

​	这个阶段同样存在两种情况，正常情况下，precommit 都响应了 ack 给到协调者，那么协调者会发起事务提交请求。

- 协调者向所有参与者发送 docommit 请求

- 参与者收到 docommit 请求后，执行事务提交操作，并释放所有事务资源

- 事务提交以后返回 ack 给到协调者

- 协调者收到所有参与者的响应后，完成事务

如果在 precommit 阶段，有参与者没有发送 ack 给到协调者，那么则执行事务中断指令

- 协调者向所有参与者发送中断事务的请求

- 参与者收到请求以后，利用在第二个阶段记录的 undo 信息来执行事务回滚操作

- 向协调者发送 ack 消息，协调者收到消息以后，执行事务中断操作



# 3. 分布式事务

### 3.1 经典的 X/OpenDTP 事务模型

​	DTP(X/Open Distributed Transaction Processing Reference Model) 是X/Open 这个组织定义的一套分布式事务的标准，也就是定义了规范和 API 接口，由各个厂商进行具体的实现。

​	  这个标准提出了使用二阶段提交(2PC – Two-Phase-Commit)来保证分布式事务的完整性。后来 J2EE 也遵循了 X/OpenDTP 规范，设计并实现了 java 里的分布式事务编程接口规范-JTA



**X/OpenDTP 角色**
​	在 X/OpenDTP 事务模型中，定义了三个角色：

- AP: application, 应用程序，也就是业务层。哪些操作属于一个事务，就是 AP 定义的
- RM： Resource Manager，资源管理器。一般是数据库，也可以是其他资源管理器，比如消息队列，文件系统
- TM： Transaction Manager ，事务管理器、事务协调者，负责接收来自用户程序（AP）发起的 



  在分布式系统中，每一个机器节点虽然都能够明确知道自己在进行事务操作过程中的结果是成功还是失败，但却无法直接获取到其他分布式节点的操作结果。因此当一个事务操作需要跨越多个分布式节点的时候，为了保持事务处理的 ACID 特性，就需要引入一个“协调者”（TM）来统一度所有分布式节点的执行逻辑，这些被调度的分布式节点被称为 AP。TM 负责调度 AP 的行为，并最终决定这些 AP 是否要把事务真正进行提交到（RM）

![](http://ww1.sinaimg.cn/large/b8a27c2fgy1g1viruejxbj20ie074gmf.jpg)

### 3.2  分布式事务之 数据库 JTA-- 强一致性

​    	在 java 中，分布式事务主要的规范是 JTA/XA . JTA 是 java 的事务管理器规范，JTA 全称为 Java Transaction API, JTA 定义了一组统一的事务编程的接口，基于X/OpenDTP 规范设计的分布式事务编程接口规范。XA 是工业标准的 X/Open DTP规范。使用JTA事务需要每一个应用系统都支持XA规范。

基于 JTA 规范的第三方分布式事务框架有 **Jotm 和 Atomikos**

#### 1）JTA实现之JOTM
​	JOTM （java open transaction manager）是 ObjectWeb 的一个开源 JTA 实现，提供 JTA 分布式事务的功能；但是 JOTM 存在一个问题，在使用中不能自动 rollback，无论什么情况都 commit。

#### 2）JTA实现之Atomikos
​	与 JOTM 相比，Atomikos 更加稳定，原本 Atomikos 是商业项目，后来开源。

**优点：** 尽量保证了数据的强一致，适合对数据强一致要求很高的关键领域。（其实也不能100%保证强一致）

**缺点：** 实现复杂，牺牲了可用性，对性能影响较大，不适合高并发高性能场景。



### 3.3 分布式事务之本地消息表--最终一致性

​		本地消息表这种实现方式应该是业界使用最多的，其核心思想是将分布式事务拆分成本地事务进行处理，这种思路是来源于ebay。我们可以从下面的流程图中看出其中的一些细节：

![](http://ww1.sinaimg.cn/large/b8a27c2fgy1g4q50govt8j20go07p3z9.jpg)

基本思路就是：

- 消息生产方，需要额外建一个消息表，并记录消息发送状态。消息表和业务数据要在一个事务里提交，也就是说他们要在一个数据库里面。然后消息会经过MQ发送到消息的消费方。如果消息发送失败，会进行重试发送。

- 消息消费方，需要处理这个消息，并完成自己的业务逻辑。此时如果本地事务处理成功，表明已经处理成功了，如果处理失败，那么就会重试执行。如果是业务上面的失败，可以给生产方发送一个业务补偿消息，通知生产方进行回滚等操作。

- 生产方和消费方定时扫描本地消息表，把还没处理完成的消息或者失败的消息再发送一遍。如果有靠谱的自动对账补账逻辑，这种方案还是非常实用的。

这种方案遵循BASE理论，采用的是最终一致性，笔者认为是这几种方案里面比较适合实际业务场景的，即不会出现像2PC那样复杂的实现(当调用链很长的时候，2PC的可用性是非常低的)，也不会像TCC那样可能出现确认或者回滚不了的情况。

**优点：** 一种非常经典的实现，避免了分布式事务，实现了最终一致性。在 .NET中 有现成的解决方案。

**缺点：** 消息表会耦合到业务系统中，如果没有封装好的解决方案，会有很多杂活需要处理。



### 3.4 分布式事务之消息事务--最终一致性

​		所谓的消息事务就是基于消息中间件的两阶段提交，本质上是对消息中间件的一种特殊利用，它是将本地事务和发消息放在了一个分布式事务里，保证要么本地操作成功成功并且对外发消息成功，要么两者都失败，开源的RocketMQ就支持这一特性，具体原理如下：

​	![](http://ww1.sinaimg.cn/large/b8a27c2fgy1g4q5dtfdwbj20fc0dp0t9.jpg)

1、A系统向消息中间件发送一条预备消息
2、消息中间件保存预备消息并返回成功
3、A执行本地事务
4、A发送提交消息给消息中间件

通过以上4步完成了一个消息事务。对于以上的4个步骤，每个步骤都可能产生错误，下面一一分析：

- 步骤一出错，则整个事务失败，不会执行A的本地操作
- 步骤二出错，则整个事务失败，不会执行A的本地操作
- 步骤三出错，这时候需要回滚预备消息，怎么回滚？答案是A系统实现一个消息中间件的回调接口，消息中间件会去不断执行回调接口，检查A事务执行是否执行成功，如果失败则回滚预备消息
- 步骤四出错，这时候A的本地事务是成功的，那么消息中间件要回滚A吗？答案是不需要，其实通过回调接口，消息中间件能够检查到A执行成功了，这时候其实不需要A发提交消息了，消息中间件可以自己对消息进行提交，从而完成整个消息事务

基于消息中间件的两阶段提交往往用在高并发场景下，将一个分布式事务拆成一个消息事务（A系统的本地操作+发消息）+B系统的本地操作，其中B系统的操作由消息驱动，只要消息事务成功，那么A操作一定成功，消息也一定发出来了，这时候B会收到消息去执行本地操作，如果本地操作失败，消息会重投，直到B操作成功，这样就变相地实现了A与B的分布式事务。原理如下：

![](http://ww1.sinaimg.cn/large/b8a27c2fgy1g4q5eaobqjj20l90dht9h.jpg)

​		虽然上面的方案能够完成A和B的操作，但是A和B并不是严格一致的，而是最终一致的，我们在这里牺牲了一致性，换来了性能的大幅度提升。当然，这种玩法也是有风险的，如果B一直执行不成功，那么一致性会被破坏，具体要不要玩，还是得看业务能够承担多少风险。



### 3.5 分布式事务之TCC

​		所谓的TCC编程模式，也是两阶段提交的一个变种。TCC提供了一个编程框架，将整个业务逻辑分为三块：Try、Confirm和Cancel三个操作。以在线下单为例，Try阶段会去扣库存，Confirm阶段则是去更新订单状态，如果更新订单失败，则进入Cancel阶段，会去恢复库存。总之，TCC就是通过代码人为实现了两阶段提交，不同的业务场景所写的代码都不一样，复杂度也不一样，因此，这种模式并不能很好地被复用。

  **XA是资源层面的分布式事务，强一致性，在两阶段提交的整个过程中，一直会持有资源的锁。**；**TCC是业务层面的分布式事务，最终一致性，不会一直持有资源的锁。**



# 5.互联网数据一致性解决方案

​	目前互联网领域里有几种流行的分布式解决方案，但都没有像之前所说的 XA 事务一样形成 X/OpenDTP 那样的工业规范，而是仅仅在具体的行业里获得较多的认可；

​	我们最早的时候讲过 CAP 和 BASE 理论，对于 CAP 来说，对于共享数据的系统，由于网络分区问题的存在，我们只能满足 AP 或者 CP；对于 BASE 理论，满足基本可用。所以其实我们在落地数据一致性解决方案是，基本上都会选择一个平衡点，也就是酸碱平衡理论，ACID 是酸、 BASE 是碱；ACID 是强一致性、BASE 是弱一致性。强一致性代表数据库本身不会出现不一致，每个事务是原子的，或者成功或者失败，事物间是隔离的，互相完全不影响，而且最终状态是持久落盘的，因此，数据库会从一个明确的状态到另外一个明确的状态.; 而 BASE 体现的是最终一致性，允许出现中间状态。

## 5.1 CAP

**C:Consistency**，一致性，就是说所有的服务器上面的数据都是一样的，

**A:Availability**，可用性，用户访问服务器上面的数据，响应时间在可以接受的范围内

**P:Partition**，分区容忍性，其实就是高可用性，一个节点崩了，并不影响我们其它的节点

所以对于对于服务来说，有很多的方案去选择：

- 1.提供查询服务确认数据状态、
- 2.幂等操作对于重发保证数据的安全性、
- 3.TCC事务操作、
- 4.补偿操作、
- 5.定期校对。

## 5.2 Base 理论

> BASE：全称：Basically Available(基本可用)，Soft state（软状态）,和 Eventually consistent（最终一致性）三个短语的缩写，来自 ebay 的架构师提出。

Base 理论是对 CAP 中一致性和可用性权衡的结果，其来源于对大型互联网分布式实践的总结，是基于 CAP 定理逐步演化而来的。其核心思想是：

> 既是无法做到强一致性（Strong consistency），但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性（Eventual consistency）。

### 1) Basically Available(基本可用)

什么是基本可用呢？假设系统，出现了不可预知的故障，但还是能用，相比较正常的系统而言：

1. 响应时间上的损失：正常情况下的搜索引擎 0.5 秒即返回给用户结果，而**基本可用**的搜索引擎可以在 1 秒作用返回结果。
2. 功能上的损失：在一个电商网站上，正常情况下，用户可以顺利完成每一笔订单，但是到了大促期间，为了保护购物系统的稳定性，部分消费者可能会被引导到一个降级页面。

### 2) Soft state（软状态）

什么是软状态呢？相对于原子性而言，要求多个节点的数据副本都是一致的，这是一种 “硬状态”。

软状态指的是：允许系统中的数据存在中间状态，并认为该状态不影响系统的整体可用性，即允许系统在多个不同节点的数据副本存在数据延时。

### 3) Eventually consistent（最终一致性）

这个比较好理解了哈。

上面说软状态，然后不可能一直是软状态，必须有个时间期限。在期限过后，应当保证所有副本保持数据一致性。从而达到数据的最终一致性。这个时间期限取决于网络延时，系统负载，数据复制方案设计等等因素。

稍微官方一点的说法就是：

> 系统能够保证在没有其他新的更新操作的情况下，数据最终一定能够达到一致的状态，因此所有客户端对系统的数据访问最终都能够获取到最新的值。




## 5.3 业务接口整合，避免分布式事务

​	这个方案就是把一个业务流程中需要在一个事务里执行的多个相关业务接口包装整合到一个事务中，比如我们可以讲 A/B/C 整合为一个服务 D 来实现单一事务的业务流程服务



## 5.4 最终一致性方案

​	eBay 在 2008 年公布了一个关于 BASE 准则提到一个分布式事务解决方案。eBay的方案其实是一个最终一致性方案，它主要采用消息队列来辅助实现事务控制流程，方案的核心是将需要分布式处理的任务通过消息队列的方式来异步执行，如果事务失败，则可以发起人工重试的纠正流程。人工重试被更多的应用于支付场景，通过对账系统对事后问题进行处理

​	比如一个很常见的场景：某个用户产生了一笔交易，那么需要在交易表中增加记录，同时需要修改用户表的金额（余额），由于这两个表属于不同的远程服务，所以就会涉及到分布式事务与数据一致性的问题.



**关于状态机**

在使用最终一致性的方案时，一定要提到的一个概念是状态机。

什么是状态机？

​	是一种特殊的组织代码的方式，用这种方式能够确保你的对象随时都知道自己所处的状态以及所能做的操作。它也是一种用来进行对象行为建模的工具，用于描述对象在它的生命周期内所经历的状态序列，以及如何响应来自外界的各种事件。

状态机这个概念大家都不陌生，比如 TCP 协议的状态机。同时我们在编写相关业务逻辑的时候经常也会需要处理各种事件和状态的切换，比如 switch、if/else。所以我们其实一直在跟状态机打交道，只是可能没有意识到而已。在处理一些业务逻辑比较复杂的需求时，可以先看看是否适合用一个有限状态机来描述，如果可以把业务模型抽象成一个有限状态机，那么代码就会逻辑特别清晰，结构特别规整。

比如我们来简单描述一个订单
​	我们以支付为例，一笔订单可能会有等待支付、支付中、已支付等状态，那么我们就可以先去把可能出现的状态以及状态的流程画出来。



**状态机的两个作用**

1. 实现幂等

2. 通过状态驱动数据的变化

3. 业务流程以及逻辑更加清晰，特别是应对复杂的业务场景