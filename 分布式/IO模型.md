传输层以下就属于系统内核操作

# 1.阻塞和非阻塞

阻塞和非阻塞：**指用户线程调用内核IO操作的方式是阻塞还是非阻塞**

​    在发起读取文件的请求时，应用层会调用系统内核的 I/O 接口。

​      如果应用层调用的是阻塞型 I/O，那么在调用之后，应用层即刻被挂起，一直处于等待数据返回的状态，直到系统内核从磁盘读取完数据并返回给应用层，应用层才用获得的数据进行接下来的其他操作。

​       如果应用层调用的是非阻塞 I/O，那么调用后，系统内核会立即返回（虽然还没有文件内容的数据），应用层并不会被挂起，它可以做其他任意它想做的操作。（至于文件内容数据如何返回给应用层，这已经超出了阻塞和非阻塞的辨别范畴。）

​          这便是（脱离同步和异步来说之后）阻塞和非阻塞的区别。总结来说，是否是阻塞还是非阻塞，关注的是接口调用（发出请求）后等待数据返回时的状态。被挂起无法执行其他操作的则是阻塞型的，可以被立即「抽离」去完成其他「任务」的则是非阻塞型的。

![](http://ww1.sinaimg.cn/mw690/b8a27c2fgy1g1m147lro0j20gw0d1wek.jpg)



# 2.同步和异步

同步和异步：**指的是用户线程和内核的交互方式**

​        阻塞和非阻塞解决了应用层等待数据返回时的状态问题，那系统内核获取到的数据到底如何返回给应用层呢？这里不同类型的操作便体现的是同步和异步的区别。

​       对于同步型的调用，应用层需要自己去向系统内核问询，如果数据还未读取完毕，那此时读取文件的任务还未完成，应用层根据其阻塞和非阻塞的划分，或挂起或去做其他事情（所以同步和异步并不决定其等待数据返回时的状态）；如果数据已经读取完毕，那此时系统内核将数据返回给应用层，应用层即可以用取得的数据做其他相关的事情。

​      而对于异步型的调用，应用层无需主动向系统内核问询，在系统内核读取完文件数据之后，会主动通知应用层数据已经读取完毕，此时应用层即可以接收系统内核返回过来的数据，再做其他事情。

​       这便是（脱离阻塞和非阻塞来说之后）同步和异步的区别。也就是说，是否是同步还是异步，关注的是任务完成时消息通知的方式。由调用方盲目主动问询的方式是同步调用，由被调用方主动通知调用方任务已完成的方式是异步调用。

![](http://ww1.sinaimg.cn/mw690/b8a27c2fgy1g1m1655j0pj20gw0d1q35.jpg)

# 3.四种IO模型

## 3.1 同步阻塞（Blocking IO）

​      同步阻塞：即传统的IO模型



## 3.2 同步非阻塞（Non -Blocking IO）

​     默认创建的socket都是阻塞的，非阻塞IO要求socket被设置为NONBLOCK。需要用户线程自己去向 内核系统获取结果，中途可以干自己的事情。

## 3.3 异步阻塞

异步阻塞IO：当前是阻塞的，不能做其他事，但是是由内核系统把IO结果返回；

   ` IO多路复用（IO Multiplexing）`即经典的Reactor设计模式，属于异步阻塞，Java中的Selector和
Linux中的epoll都是这种模型。

## 3.4 异步非阻塞

​	即经典的Proactor设计模式，也称为异步非阻塞IO。