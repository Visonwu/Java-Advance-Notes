HashMap   版本：jdk1.8



# 1.红黑树

​      R-B Tree，全称是Red-Black Tree，又称为“红黑树”，它一种特殊的二叉查找树。红黑树的每个节点上都有存储位表示节点的颜色，可以是红(Red)或黑(Black)。

**红黑树的特性**:
**（1）每个节点或者是黑色，或者是红色。**
**（2）根节点是黑色。**
**（3）每个叶子节点（NIL）是黑色。 [注意：这里叶子节点，是指为空(NIL或NULL)的叶子节点！]**
**（4）如果一个节点是红色的，则它的子节点必须是黑色的。**
**（5）从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。**

**注意**：
(01) 特性(3)中的叶子节点，是只为空(NIL或null)的节点。
(02) 特性(5)，确保没有一条路径会比其他路径长出俩倍。因而，红黑树是相对是接近平衡的二叉树。



# 2.数据结构

   数组+链表+红黑树

- 数据：Node<K,V>[] table

- 链表：hash，key，value，next

- 红黑树：parent，left，right，prev，red


![](http://ww1.sinaimg.cn/large/b8a27c2fgy1g1rhtucv7pj20h106aq2w.jpg)



# 2.初始化

- 1.**默认容量大小是16**

- 2.**负载因子默认0.75**，用来判定数组是否需要扩容，当添加的个数满足 16\*0.75 (数组大小\*负载因子)后，就**两倍的扩容**

- 3.**初始化大小必须为2的幂次方**，如果不是自动转换(如果给10，会转换为16，算法如下)。

  - 理由：获取key的时候 `(n - 1) & hash`效率更高，

    - **&**比取模效率更高，
    - **能保证 索引值 肯定在 capacity 中，不会超出数组长度**
    - hash变量只有末x位会参与到运算，只用获取hash后n-位值，n-1相当于不起作用；

  - 算法，保证最高位之后都变成1：

    ```java
    	static final int tableSizeFor(int cap) {
            int n = cap - 1;
            n |= n >>> 1;
            n |= n >>> 2;
            n |= n >>> 4;
            n |= n >>> 8;
            n |= n >>> 16;
            return (n < 0) ? 1 : (n >= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;
        }
    ```


# 3.Put操作

1. 先对key求`hash值`，然后`计算下标`

2. 判定当前数组的大小，看是否做`resize操作`（这里其实是做初始化，扩容是在添加成功后再做处理）

3. 获取当前下标的值，如果为空就把当前的值放到当前位置	

4. 如果不为空，判定`hash值和key值(这里可以是==或者equal)`是否相同，相同修改value值即可

5. 如果不为空，判定`hash值和key值(这里可以是==或者equal)`是否相同，不相同则作如下操作

   - 判定当前下标的值是否是`TreeNode`，如果是`TreeNode`，则做红黑树操作

   - 否则做链表操作：

     - 如果链表的长度超过`TREEIFY_THRESHOLD(8)`，则转换为TreeNode；

       - 如果此时的容器的长度小于`MIN_TREEIFY_CAPACITY（64）`，会做扩容

       注：如果红黑树做删除元素的时候，少于`UNTREEIFY_THRESHOLD（6）`的时，会转为链表

     - 否则链表的末端添加当前这个元素

6. size 增加1，并判定当前的数组大小是否需要扩容，如果数组大小超过`(数组大小\*负载因子)`,默认16*0.75则会做`扩容`操作

## 3.1 hash 值计算

​	当前key的hashcode值，高16位和低16位进行异或操作，降低hash值的碰撞，

​		原因，因为hash中数组一般数据不大，一般只能用到低16的位和数组大小进行与操作，所以为了减少hash碰撞，让高16也参与运算。

源码：

```java
 static final int hash(Object key) {
     int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
 }
```

## 3.2 resize操作（扩容或者初始化容器大小）

-   如果没有给定容器大小，默认给定容器大小16

-  当数据结构中总的数据满足 12(16\*0.75；数组大小\*负载因子)后，就**两倍的扩容**，

- 扩容后，原先的数据处理

  - 1.当前bin只有一个元素：**重新把当前key重新做hash放入新的数组中**（jdk1.8不是重新做hash运算）

  - 2.当前的bin是一个红黑树：

  - 3.当前bin是一个链表：

    通过判定`if ((e.hash & oldCap) == 0)`来判定扩容后，当前链表是放在`原来下标位置`，还是在`原来下标位置+原来容器的大小`

    ```java
    e.hash & oldCap  原理
    
      01111   	//原来的hash值
      10000 &   //oldCap原来容器的大小
     ----------
      00000  
    这样当原来的hash值更高一位是1的话，就把值放到 (原来下标位置+原来容器的大小)下标位置
    否则还是原来的下标位置
    
    为0的时候放在原来的位置，否则放在原来下标位置+原来容器的大小)下标位置
    ```


## 3.3 获取bin下标值

```java
//源码：
tab[i = (n - 1) & hash])
```

`(n - 1) & hash`    

- n :  这里的n表示容器的大小，必须是2的倍数；
  - 一般n-1的形式是`011111`	
  - 这里也是在获取bin下标值更有效率。
  - 相当于取下标值的时候，n不会对这个有影响，把下标选择交给hash值，并且能够保证下标不会越界；

- & : 这里的`&`效率比取模`%`效率高；

- hash：hash值是通过key的hashcode的高16位和低16位进行异或操作，降低hash值的碰撞。这样的容器的下标更加分散，降低查询时间度



# 4.Get操作

1. 判定容器的大小不为空，并且获取当key的hash值，下标值找到节点
2. 如果当前节点的和查询的hash值，key的值(==,equal)相同，则直接返回当前的节点
3. 否则，判断当前是否是TreeNode,则从TreeNode节点中遍历获取
4. 否则，通过链表遍历操作，返回节点信息

​	

# 5. 链表长度大于8和小于6

​	为什么链表长度大于8的时候转换为8的时候转换为红黑树，而小于6的时候才转换为链表，7跑哪儿去了？

答：原因是如果一个数据链表在大小为6的时候不停的增加或者删除那么就会在链表和红黑树之间不停的转换，会增加不停的转换消耗，这样也是为了做一个缓冲作用。



# 6.jdk1.7和jdk1.8的HashMap比较

|            | jdk1.7的HashMap                                              | jdk1.8的HashMap                                |
| ---------- | ------------------------------------------------------------ | ---------------------------------------------- |
| 数据结构   | 数组+链表                                                    | 数组+链表+红黑树                               |
| 链表插入法 | 头插法(链表头部插入，容易出现**多线程同时put和get时容易出现死循环问题**) | 尾插法（链表尾部插入）                         |
| 扩容       | 先扩容再put                                                  | 先put再扩容                                    |
| hash值     | hash运算多                                                   | hash运算少                                     |
| resize的值 | 受rehash影响                                                 | (原位置)or(原位置+旧容量)                      |
| 初始化     | 初始化table为16                                              | 只初始化负载因子，第一次添加才初始化容量大小16 |

