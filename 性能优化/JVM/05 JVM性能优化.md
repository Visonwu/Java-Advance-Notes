# 1. 垃圾发生时间

> GC是由JVM自动完成的，根据JVM系统环境而定，所以时机是不确定的。 当然，我们可以手动进行垃圾回收，比如调用System.gc()方法通知JVM进行一次垃圾回收，但是具体什么时刻运行也无法控制。也就是说
> System.gc()只是通知要回收，什么时候回收由JVM决定。 但是不建议手动调用该方法，因为消耗的资源比较
> 大。

一般以下几种情况会发生垃圾回收:

```text
（1）当Eden区或者S区不够用了
（2）老年代空间不够用了
（3）方法区空间不够用了
（4）System.gc()
```



# 2. G1调优指南

> 是否选用G1垃圾收集器的判断依据?
> https://docs.oracle.com/javase/8/docs/technotes/guides/vm/G1.html#use_cases

```text
（1）50%以上的堆被存活对象占用
（2）对象分配和晋升的速度变化非常大
（3）垃圾回收时间比较长
```

> 思考：https://blogs.oracle.com/poonam/increased-heap-usage-with-g1-gc

## 2.1 分别设置参数

>-XX:MaxGCPauseMillis=20 设置最大GC停顿时间指标
>
> -XX:+UseG1GC  使用G1GC垃圾收集器
>
>-XX:InitiatingHeapOccupancyPercent=45 G1用它来触发并发GC周期,基于整个堆的使用率,而不只是某一代内存的使用比例。值为 0 则表示“一直执行GC循环)'. 默认值为 45 (例如, 全部的 45% 或者使用了45%).



## 2.2 最佳调优

官网建议：https://docs.oracle.com/javase/8/docs/technotes/guides/vm/gctuning/g1_gc_tuning.html#recommendations

(1)不要手动设置新生代和老年代的大小，只要设置整个堆的大小

```text
G1收集器在运行过程中，会自己调整新生代和老年代的大小
其实是通过adapt代的大小来调整对象晋升的速度和年龄，从而达到为收集器设置的暂停时间目标
如果手动设置了大小就意味着放弃了G1的自动调优
```

(2)不断调优暂停时间目标

```text
一般情况下这个值设置到100ms或者200ms都是可以的(不同情况下会不一样)，但如果设置成50ms就不太合理。暂停
时间设置的太短，就会导致出现G1跟不上垃圾产生的速度。最终退化成Full GC。所以对这个参数的调优是一个持续
的过程，逐步调整到最佳状态。暂停时间只是一个目标，并不能总是得到满足。
```

(3)使用-XX:ConcGCThreads=n来增加标记线程的数量

```text
IHOP(InitiatingHeapOccupancyPercent)如果阀值设置过高，可能会遇到转移失败的风险，比如对象进行转移时空间不足。如果阀值设置过低，就会使标
记周期运行过于频繁，并且有可能混合收集期回收不到空间。
IHOP值如果设置合理，但是在并发周期时间过长时，可以尝试增加并发线程数，调高ConcGCThreads。
```

(4)MixedGC调优

```text
-XX:InitiatingHeapOccupancyPercent
-XX:G1MixedGCLiveThresholdPercent
-XX:G1MixedGCCountTarger
-XX:G1OldCSetRegionThresholdPercent
```

(5)适当增加堆内存大小



# 3.高并发场景实例分析

> 以每秒3000笔订单做分析

如果这个3000笔订单有三个服务，那么每一个服务有1000笔那么



> order(1k) * 1000 =1000kb    //创建一个订单对象假如1kb
>
> ->  1000 * 20 约等于 20MB  //同级大概有20个对象创建
>
> -> 如果堆内存为4000MB（4G）,那么young去大约1333MB
>
> -> 那么大概65s，也就是一分钟young区不够用了，老年代也很快会满了
>
> -> 所以此时为了减少Full GC,，把young区域调大一点，也不定1:2



# 4.常见问题思考

**（1）内存泄漏与内存溢出的区别**

- **内存泄漏：**对象无法得到及时的回收，持续占用内存空间，从而造成内存空间的浪费。
- **内存溢出**：内存泄漏到一定的程度就会导致内存溢出，但是内存溢出也有可能是大对象导致的。

**（2）young gc会有stw吗？**
          不管什么 GC，都会有 stop-the-world，只是发生时间的长短。

**（3）major gc和full gc的区别**
            major gc指的是老年代的gc，而full gc等于young+old+metaspace的gc。

**（4）G1与CMS的区别是什么?**

- CMS 用于老年代的回收，而 G1 用于新生代和老年代的回收。
- G1 使用了 Region 方式对堆内存进行了划分，且基于标记整理算法实现，整体减少了垃圾碎片的产生。

**（5）什么是直接内存?**
           直接内存是在java堆外的、直接向系统申请的内存空间。通常访问直接内存的速度会优于Java堆。因此出于性能的考虑，读写频繁的场合可能会考虑使用直接内存。

**（6）不可达的对象一定要被回收吗？**

​           即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 finalize 方法。当对象没有覆盖 finalize 方法，或 finalize 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。

**（7）方法区中的无用类回收**
	方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？
         判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同满足下面 3 个条件才能算是 “无用的类” ：

- 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。

- 加载该类的 ClassLoader 已经被回收。

- 该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。

  虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。

