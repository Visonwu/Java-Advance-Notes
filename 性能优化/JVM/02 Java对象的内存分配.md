​		

# 1.Java对象结构

参考：<https://www.cnblogs.com/duanxz/p/4967042.html>

​		HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：**对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）**

![lPDD0K.png](https://s2.ax1x.com/2019/12/24/lPDD0K.png)



## 1.1 对象头

- **1）Mark Word（标记字段）**

  HotSpot虚拟机的**对象头**包括两部分信息，第一部分是**“Mark Word**”，用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等

- **对象头的另外一部分是类型指针**，即是对象指向它的类的元数据的指针



## 1.2 实例数据（Instance Data）

接下来实例数据部分是对象真正存储的有效信息，也既是我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的都需要记录下来。 这部分的存储顺序会受到虚拟机分配策略参数（FieldsAllocationStyle）和字段在Java源码中定义顺序的影响。HotSpot虚拟机 默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops（Ordinary Object Pointers），从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果 CompactFields参数值为true（默认为true），那子类之中较窄的变量也可能会插入到父类变量的空隙之中。



## 1.3 对齐填充

​		第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说就是对象的大小必须是8字节的整数倍。对象头正好是8字节的倍数（1倍或者2倍），因此当对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。



# 2.对象创建流程

​		Java是一门面向对象的编程语言，Java程序运行过程中无时无刻都有对象被创建出来。在语言层面上，创建对象通常（例外：克隆、反序列化）仅仅是一个 new关键字而已，而在虚拟机中，对象（本文中讨论的对象限于普通Java对象，不包括数组和Class对象等）的创建又是怎样一个过程呢？ 

```text
虚拟机遇到一条new指令时:

1、首先jvm要检查类A是否已经被加载到了内存，即类的符号引用是否已经在常量池中，并且检查这个符号引用代表的类是否已被加载、解析和初始化过的。如果还没有，需要先触发类的加载、解析、初始化。然后在堆上创建对象。

2、为新生对象分配内存。

　　对象所需内存的大小在类加载完成后便可完全确定，为对象分配空间的任务具体便等同于一块确定大小的内存从Java堆中划分出来，怎么划呢？
　　
　　假设Java堆中内存是绝对规整的，所有用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作 为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump The Pointer）。
　　如果Java堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错，那就没有办法简单的进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（Free List）。
　　选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因 此在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的 收集器时（说明一下，CMS收集器可以通过UseCMSCompactAtFullCollection或 CMSFullGCsBeforeCompaction来整理内存），就通常采用空闲列表。 
　　除如何划分可用空间之外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是 线程安全的，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存。
　　解决这个问题有两个方案:
　　一种是对分配内存空 间的动作进行同步——实际上虚拟机是采用CAS配上失败重试的方式保证更新操作的原子性；
　　另外一种是把内存分配的动作按照线程划分在不同的空间之中进行， 即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲区，（TLAB ，Thread Local Allocation Buffer），哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完，分配新的TLAB时才需要同步锁定。虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定。
	

3. 完成实例数据部分的初始化工作（初始化为0值）

　　内存分配完成之后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB的话，这一个工作也可以提前至TLAB分配时进行。这 步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。

4、 完成对象头的填充：如对象自身的运行时数据、类型指针等。

　　接下来，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。

在上面工作都完成之后，在虚拟机的视角来看，一个新的对象已经产生了。但是在Java程序的视角看来，初始化才正式开始，开始调用<init>方法完成初始复制和构造函数，所有的字段都为零值。因此一般来说（由字节码中是否跟随有invokespecial指令所决定），new指令之后会接着就是执 行<init>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全创建出来。
```



# 3.内存分配方法

## 3.1 指针碰撞

  指针碰撞(Serial、ParNew等带Compact过程的收集器)

​		假设Java堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式称为“指针碰撞”（Bump the Pointer）。

## 3.2  空闲列表

  空闲列表(CMS这种基于Mark-Sweep算法的收集器)

​	如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”（Free List）



# 4.对象分配

​	在学习Java的过程中，一般认为new出来的对象都是被分配在堆上的，其实这个结论不完全正确，因为是大部分new出来的对象被分配在**堆**上，而不是全部。通过对Java对象分配的过程分析，可以知道有另外两个地方也是可以存放对象的。这两个地方分别**栈** （涉及逃逸分析相关知识）和**TLAB**（Thread Local Allocation Buffer）

![lPg6tf.png](https://s2.ax1x.com/2019/12/24/lPg6tf.png)

## 4.1 栈上分配

​		在JVM中，堆是线程共享的，因此堆上的对象对于各个线程都是共享和可见的，只要持有对象的引用，就可以访问堆中存储的对象数据。虚拟机的垃圾收集系统可以回收堆中不再使用的对象，但对于垃圾收集器来说，无论筛选可回收对象，还是回收和整理内存都需要耗费时间。

  如果确定一个对象的作用域不会逃逸出方法之外，那可以将这个对象分配在栈上，这样，对象所占用的内存空间就可以随栈帧出栈而销毁。在一般应用中，不会逃逸的局部对象所占的比例很大，如果能使用栈上分配，那大量的对象就会随着方法的结束而自动销毁了，无须通过垃圾收集器回收，可以减小垃圾收集器的负载。

  JVM允许将线程私有的对象打散分配在栈上，而不是分配在堆上。分配在栈上的好处是可以在函数调用结束后自行销毁，而不需要垃圾回收器的介入，从而提高系统性能。 



**栈上分配前提：**

- 开启逃逸分析 (-XX:+DoEscapeAnalysis)；逃逸分析的作用就是分析对象的作用域是否会逃逸出方法之外，在server虚拟机模式下才可以开启（jdk1.6默认开启）

- 开启标量替换 (-XX:+EliminateAllocations)；标量替换的作用是允许将对象根据属性打散后分配再栈上，默认该配置为开启

  ```text
  一、标量替换
  
  1.标量和聚合量
  	标量即不可被进一步分解的量，而JAVA的基本数据类型就是标量（如：int，long等基本数据类型以及reference类型等），标量的对立就是可以被进一步分解的量，而这种量称之为聚合量。而在JAVA中对象就是可以被进一步分解的聚合量。
  
  2.替换过程
  	通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而会将该对象成员变量分解若干个被这个方法使用的成员变量所代替。这些代替的成员变量在栈帧或寄存器上分配空间
  ```

  

**查看逃逸结果**：可以通过选项-XX:+PrintEscapeAnalysis查看逃逸分析的筛选结果

```text
逃逸分析的基本行为就是分析对象的动态作用域：当一个对象在方法中被定义后，它可能被外部方法所引用。

方法逃逸：例如作为调用参数传递到其他方法中。
线程逃逸：有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量。
可以参考：https://blog.csdn.net/yangzl2008/article/details/43202969
```



## 4.2 TLAB线程本地分配缓存

​	TLAB的全称是Thread Local Allocation Buffer，即线程本地分配缓存区，这是一个线程专用的内存分配区域。 
  

​		由于对象一般会分配在堆上，而堆是全局共享的。因此在同一时间，可能会有多个线程在堆上申请空间。因此，每次对象分配都必须要进行同步（虚拟机采用CAS配上失败重试的方式保证更新操作的原子性），而在竞争激烈的场合分配的效率又会进一步下降。JVM使用TLAB来避免多线程冲突，在给对象分配内存时，每个线程使用自己的TLAB，这样可以避免线程同步，提高了对象分配的效率。 
  TLAB本身占用Eden区空间，在开启TLAB的情况下，虚拟机会为**每个Java线程分配一块TLAB空间**。参数-XX:+UseTLAB开启TLAB，默认是开启的。TLAB空间的内存非常小，缺省情况下仅占有整个Eden空间的1%，当然可以通过选项-XX:TLABWasteTargetPercent设置TLAB空间所占用Eden空间的百分比大小。 
  由于TLAB空间一般不会很大，因此大对象无法在TLAB上进行分配，总是会直接分配在堆上。TLAB空间由于比较小，因此很容易装满。比如，一个100K的空间，已经使用了80KB，当需要再分配一个30KB的对象时，肯定就无能为力了。这时虚拟机会有两种选择，第一，废弃当前TLAB，这样就会浪费20KB空间；第二，将这30KB的对象直接分配在堆上，保留当前的TLAB，这样可以希望将来有小于20KB的对象分配请求可以直接使用这块空间。实际上虚拟机内部会维护一个叫作refill_waste的值，当请求对象大于refill_waste时，会选择在堆中分配，若小于该值，则会废弃当前TLAB，新建TLAB来分配对象。这个阈值可以使用TLABRefillWasteFraction来调整，它表示TLAB中允许产生这种浪费的比例。默认值为64，即表示使用约为1/64的TLAB空间作为refill_waste。默认情况下，TLAB和refill_waste都会在运行时不断调整的，使系统的运行状态达到最优。如果想要禁用自动调整TLAB的大小，可以使用-XX:-ResizeTLAB禁用ResizeTLAB，并使用-XX:TLABSize手工指定一个TLAB的大小。 

  `-XX:+PrintTLAB`可以跟踪TLAB的使用情况。一般不建议手工修改TLAB相关参数，推荐使用虚拟机默认行为。



## 4.3 堆上分配

​	Java内存分配图如下：

![lFrX24.png](https://s2.ax1x.com/2019/12/25/lFrX24.png)

### 1） 对象优先在Eden分配

步骤如下：

- 1）将新生代内存分为一块较大的Eden空间和两块较小的Survivor空间；
- 2）每次使用Eden和其中一块Survivor；
- 3）当回收时将Eden和使用中的Survivor中还存活的对象一次性复制到另外一块Survivor；
- 4）而后清理掉Eden和使用过的Survivor空间；
- 5）后面就使用Eden和复制到的那一块Survivor空间，重复步骤3；

> 默认Eden：Survivor=8:1，即每次可以使用90%的空间，只有一块Survivor的空间被浪费；
>
> 大多数情况下，对象在新生代Eden区中分配；
>
> 当Eden区没有足够空间进行分配时，JVM将发起一次Minor GC（新生代GC）；
>
> Minor GC时，如果发现存活的对象无法全部放入Survivor空间，只好通过分配担保机制提前转移到老年代。

### 2） 大对象直接进入老年代

  大对象指需要大量连续内存空间的Java对象，如，很长的字符串、数组；经常出现大对象容易导致内存还有不少空间就提前触发GC,以获取足够的连续空间来存放它们，所以应该尽量避免使用创建大对象；

  “-XX:PretenureSizeThreshold”：可以设置这个阈值，大于这个参数值的对象直接在老年代分配； 默认为0（无效），且只对Serail和ParNew两款收集器有效；如果需要使用该参数，可考虑ParNew+CMS组合。

### 3） 长期存活的对象将进入老年代

  JVM给每个对象定义一个对象年龄计数器，其计算流程如下：

  在Eden中分配的对象，经Minor GC后还存活，就复制移动到Survivor区，年龄为1；而后每经一次Minor GC后还存活，在Survivor区复制移动一次，年龄就增加1岁； 如果年龄达到一定程度，就晋升到老年代中；

  “-XX:MaxTenuringThreshold”：设置新生代对象晋升老年代的年龄阈值，默认为15；

### 4） 动态对象年龄判定

  JVM为更好适应不同程序，不是永远要求等到MaxTenuringThreshold中设置的年龄；如果在Survivor空间中相同年龄的所有对象大小总和大于Survivor空间的一半，大于或等于该年龄的对象就可以直接进入老年代。
  -XX:TargetSurvivorRatio

### 5） 空间分配担保

  当Survivor空间不够用时，需要依赖其他内存（老年代）进行分配担保（Handle Promotion）；

**分配担保的流程如下：**

- 在发生Minor GC前，JVM先检查老年代最大可用的连续空间是否大于新生所有对象空间；
- 如果大于，那可以确保Minor GC是安全的；
- 如果不大于，则JVM查看HandlePromotionFailure值是否允许担保失败；
- 如果允许，就继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小；
- 如果大于，将尝试进行一次Minor GC，但这是有风险的；
- 如果小于或HandlePromotionFailure值不允许冒险，那这些也要改为进行一次Full GC；

**尝试Minor GC的风险–担保失败：**
  因为尝试Minor GC前，无法知道存活的对象大小，所以使用历次晋升到老年代对象的平均大小作为经验值；假如尝试的Minor GC最终存活的对象远远高于经验值的话，会导致担保失败（Handle Promotion Failure）；失败后只有重新发起一次Full GC，这绕了一个大圈，代价较高；



## 4.4 常见问题

- 如何理解Minor/Major/Full GC

  ```text
  Minor GC:新生代
  Major GC:老年代
  Full GC:新生代+老年代
  ## Major GC常伴随Minor GC
  ```

- 为什么需要Survivor区?只有Eden不行吗？

  ```text
  	如果没有Survivor,Eden区每进行一次Minor GC,并且没有年龄限制的话，存活的对象就会被送到老年代。这样一来，老年代很快被填满,触发Major GC(因为Major GC一般伴随着Minor GC,也可以看做触发了Full GC)。老年代的内存空间远大于新生代,进行一次Full GC消耗的时间比Minor GC长得多。执行时间长有什么坏处?频发的Full GC消耗的时间很长,会影响大型程序的执行和响应速度。
  
  可能你会说，那就对老年代的空间进行增加或者较少咯。
  	假如增加老年代空间，更多存活对象才能填满老年代。虽然降低Full GC频率，但是随着老年代空间加大,一旦发生FullGC,执行所需要的时间更长。假如减少老年代空间，虽然Full GC所需时间减少，但是老年代很快被存活对象填满,Full GC频率增加。
  
  	所以Survivor的存在意义,就是减少被送到老年代的对象,进而减少Full GC的发生,Survivor的预筛选保证,只有经历16次Minor GC还能在新生代中存活的对象,才会被送到老年代。
  ```

- 为什么需要两个Survivor区？

  ```text
  	最大的好处就是解决了碎片化。也就是说为什么一个Survivor区不行?第一部分中,我们知道了必须设置Survivor区。
  	假设现在只有一个Survivor区,我们来模拟一下流程:
  刚刚新建的对象在Eden中,一旦Eden满了,触发一次Minor GC,Eden中的存活对象就会被移动到Survivor区。这样继续循环下去,下一次Eden满了的时候,问题来了,此时进行Minor GC,Eden和Survivor各有一些存活对象,如果此时把Eden区的存活对象硬放到Survivor区,很明显这两部分对象所占有的内存是不连续的,也就导致了内存碎片化。
  永远有一个Survivor space是空的,另一个非空的Survivor space无碎片。
  ```

- 新生代中Eden:S1:S2为什么是8:1:1？

  ```text
  新生代中的可用内存：复制算法用来担保的内存为9：1
  可用内存中Eden：S1区为8：1
  即新生代中Eden:S1:S2 = 8：1：1
  ```



