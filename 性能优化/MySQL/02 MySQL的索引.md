# 1.索引是什么

​		数据库索引，是数据库管理系统（DBMS）中一个排序的数据结构，以协助快速查询、更新数据库表中数据。

> ​	首先数据是以文件的形式存放在磁盘上面的，每一行数据都有它的磁盘地址。如果没有索引的话，要从500 万行数据里面检索一条数据，只能依次遍历这张表的全部数据，直到找到这条数据。
>
> ​	但是有了索引之后，只需要在索引里面去检索这条数据就行了，因为它是一种特殊的专门用来快速检索的数据结构，我们找到数据存放的磁盘地址以后，就可以拿到数据了。

​	**特点：**

```text
1. 索引能极大的减少存储引擎需要扫描的数据量
2. 索引可以把随机IO变成顺序IO
3. 索引可以帮助我们在进行 分组、 排序等操作时，避免使用临时表
```



## 1.1 索引类型

在InnoDB 里面，索引类型有三种，普通索引、唯一索引（主键索引是特殊的唯一索引）、全文索引。

- **普通（Normal）**：也叫非唯一索引，是最普通的索引，没有任何的限制。

- **唯一（Unique）**：唯一索引要求键值不能重复。另外需要注意的是，主键索引是一种特殊的唯一索引，它还多了一个限制条件，要求键值不能为空。主键索引用primay key创建。

- **全文（Fulltext）**：针对比较大的数据，比如我们存放的是消息内容，有几KB 的数据的这种情况，如果要解决like 查询效率低的问题，可以创建全文索引。只有文本类型的字段才可以创建全文索引，比如char、varchar、text。

  ```sql
  -- 创建全文索引
  create table m3 (name varchar(50),fulltext index(name));
  
  -- 使用全文索引
  select * from fulltext_test where match(content) against('vison' IN NATURAL LANGUAGE MODE);
  ```

  MyISAM 和InnoDB 支持全文索引。



# 2.索引的底层结构

​		我们打开这样一个网站来看一下，这里面有各种各样的数据结构的动态演示，包括BST 二叉查找树：
​	https://www.cs.usfca.edu/~galles/visualization/Algorithms.html

## 2.1.索引底层结构演化

### 1） 二叉树

​	二叉查找树既能够实现快速查找，又能够实现快速插入。

![lBJAGq.png](https://s2.ax1x.com/2020/01/05/lBJAGq.png)

**问题：**
		就是它的查找耗时是和这棵树的深度相关的，在最坏的情况下时间复杂度会退化成O(n)。



### 2） AVL 平衡二叉树

平衡二叉树的定义：左右子树深度差绝对值不能超过1。是什么意思呢？比如左子树的深度是2，右子树的深度只能是1 或者3。
这个时候我们再按顺序插入1、2、3、4、5、6，一定是这样，不会变成一棵“斜树”

![lBJYQK.png](https://s2.ax1x.com/2020/01/05/lBJYQK.png)

```text
前面两个二叉树可以总结如下：

1) 它太深了
     数据处的（高）深度决定着他的IO 操作次数，IO 操作耗时大,如上图如果要找到索引3需要经过三次IO。
     
2) 它太小了
   i:每一个磁盘块 （节点/ 页） 保存的数据量太小 了（一个节点只有一个关键字和相应的数据，信息太少）
   ii:没有很好的利用操作磁盘IO 的数据 交换 特性（一个磁盘16k，估计只用了1k，多次IO后获取到的无用信息太多）
   iii:也没有利用好磁盘IO 的预读能力（操作系统定义的空间局部性原理 ），从而带来频繁的IO。（在你读取当前节点时，它认为你要读取接下来的节点，帮你提前读）

```



### 3）B-Tree 多路平衡二叉树

​		这里多路指的一个磁盘块（节点）有n个子节点，那么当前节点就保存了n-1个关键字的数据。下面这个图就是三路，一个节点保存了两个关键字的信息和三个节点的引用。

 这样相比二叉树，每一个节点的信息也就可以存储更多的信息了，如图：

![lBJReg.png](https://s2.ax1x.com/2020/01/05/lBJReg.png)



### 4）B+Tree 加强多路平衡二叉树

​	**B+Tree**：加强版多路平衡查找树 ；相比B-Tree树，做了如下改变。

- 它的关键字的数量是跟路数相等的；

- 磁盘块不在保存关键字的信息（索引对应数据的地址引用）,而只是保存在叶子节点上；
- 并且采用左闭合的方式；
- B+Tree 的每个叶子节点增加了一个指向相邻叶子节点的指针，它的最后一个数据会指向下一个叶子节点的第一个数据，形成了一个有序链表的结构

![lBN1ij.png](https://s2.ax1x.com/2020/01/05/lBN1ij.png)

```text
例子：
假设一条记录是1K，一个叶子节点（一页）可以存储16 条记录。非叶子节点可以存储多少个指针？

	假设索引字段是bigint 类型，长度为8 字节。指针大小在InnoDB 源码中设置为6字节，这样一共14 字节。非叶子节点（一页）可以存储16384/14=1170 个这样的单元（键值+指针），代表有1170 个指针。
树深度为2 的时候， 有1170^2 个叶子节点， 可以存储的数据为1170*1170*16=21902400。

在查找数据时一次页的查找代表一次IO，也就是说，一张2000 万左右的表，查询数据最多需要访问3 次磁盘。
所以在InnoDB 中B+ 树深度一般为1-3 层，它就能满足千万级的数据存储。
```

总结一下，InnoDB 中的B+Tree 的特点：

- 1)它是B Tree 的变种，B Tree 能解决的问题，它都能解决。B Tree 解决的两大问题是什么？（每个节点存储更多关键字；路数更多）
- 2)扫库、扫表能力更强（如果我们要对表进行全表扫描，只需要遍历叶子节点就可以了，不需要遍历整棵B+Tree 拿到所有的数据）
- 3) B+Tree 的磁盘读写能力相对于B Tree 来说更强（根节点和枝节点不保存数据区，所以一个节点可以保存更多的关键字，一次磁盘加载的关键字更多）
- 4)排序能力更强（因为叶子节点上有下一个数据区的指针，数据形成了链表）
- 5)效率更加稳定（B+Tree 永远是在叶子节点拿到数据，所以IO 次数是稳定的）



# 3.不同存储引擎中索引的落地方式

## 3.1 Innodb引擎

> https://dev.mysql.com/doc/refman/5.7/en/innodb-disk-management.html
> https://dev.mysql.com/doc/refman/5.7/en/innodb-file-space.html

### 1) Innodb的存储结构

Innodb的存储结构分为5 级：表空间、段、簇、页、行。

![lBU10O.png](https://s2.ax1x.com/2020/01/05/lBU10O.png)



> - **表空间Table Space**
>   		表空间可以看做是InnoDB 存储引擎逻辑结构的最高层，所有的数据都存放在表空间中。分为：系统表空间、独占表空间、通用表空间、临时表空间、Undo 表空间。
>
> - **段Segment**
>           表空间是由各个段组成的，常见的段有数据段、索引段、回滚段等，段是一个逻辑的概念。一个ibd 文件（独立表空间文件）里面会由很多个段组成。
>   创建一个索引会创建两个段，一个是索引段：leaf node segment，一个是数据段：non-leaf node segment。索引段管理非叶子节点的数据。数据段管理叶子节点的数据。也就是说，一个表的段数，就是索引的个数乘以2。
>
> - **簇Extent**
>           一个段（Segment）又由很多的簇（也可以叫区）组成，每个区的大小是1MB（64个连续的页）。
>   每一个段至少会有一个簇，一个段所管理的空间大小是无限的，可以一直扩展下去，但是扩展的最小单位就是簇。
>
> - **页Page**
>           为了高效管理物理空间，对簇进一步细分，就得到了页。簇是由连续的页（Page）组成的空间，一个簇中有64 个连续的页。（1MB／16KB=64）。这些页面在物理上和逻辑上都是连续的。
>   跟大多数数据库一样，InnoDB 也有页的概念（也可以称为块），每个页默认16KB。
>   页是InnoDB 存储引擎磁盘管理的最小单位，通过innodb_page_size 设置。
>
>   ​       一个表空间最多拥有2^32 个页，默认情况下一个页的大小为16KB，也就是说一个表空间最多存储64TB 的数据。
>
>   
>
>   注意，文件系统中，也有页的概念。
>   操作系统和内存打交道，最小的单位是页Page。文件系统的内存页通常是4K。
>
>   ![lBU4BT.png](https://s2.ax1x.com/2020/01/05/lBU4BT.png)



- 往表中插入数据时，如果一个页面已经写完，产生一个新的叶页面。如果一个簇的所有的页面都被用完，会从当前页面所在段新分配一个簇。
- 如果数据不是连续的，往已经写满的页中插入数据，会导致叶页面分裂：

### 2) Innodb的索引

​		Innodb引擎创建的时候：默认都是使用**B+Tree加强版的多路平衡二叉树**；

​		但是我们选择的时候用Navicat建表的时候有一个Hash-Index选项，这个其实只是自适应hash索引而已，并不会为索引创建为hash-index;

自适应hash索引：只是会为热点数据建立hash-index；这个我们是无法受控的

Buffer pool 里面有一块区域是Adaptive Hash Index 自适应哈希索引，就是这个。这个开关默认是ON：

#### 1）Innodb的索引物理位置

- Innodb的索引和数据在磁盘中存放都是放在.idb文件中



#### 2）Innodb的索引查询方式

​			InnoDB的数据和索引是存储在一起的，数据都是以主键为索引来组织存储的。如果没有设置主键，innodb会默认生成一个隐式主键索引。

```text
A:为什么在辅助索引里面存储的是主键值而不是主键的磁盘地址呢？如果主键的数据类型比较大，是不是比存地址更消耗空间呢？我们前面说到B+Tree 是怎么实现一个节点存储多个关键字，还保持平衡的呢？
   1、是因为有分叉和合并的操作，这个时候键值的地址会发生变化，所以在辅助索引里面不能存储地址。

B：另一个问题，如果一张表没有主键怎么办？
	1、如果我们定义了主键(PRIMARY KEY)，那么InnoDB 会选择主键作为聚集索引。
	2、如果没有显式定义主键，则InnoDB 会选择第一个不包含有NULL 值的唯一索引作为主键索引。
	3、如果也没有这样的唯一索引，则InnoDB 会选择内置6 字节长的ROWID 作为隐藏的聚集索引，它会随着行记录的写入而主键递增。
```





**i：主键为索引的B+Tree的表现形式，叶节点是数据信息**

​     **如下聚集索引就是叶子节点保存着数据的信息，这里的聚集索引就是主键。**

![lBw5Hf.png](https://s2.ax1x.com/2020/01/05/lBw5Hf.png)



**ii: 其他辅助索引的B+Tree的表现形式**

​       这里辅助索引，也称为二级索引，叶节点储存的信息是主键的信息。如图

![lBw74g.png](https://s2.ax1x.com/2020/01/05/lBw74g.png)



## 3.2 MyISAM的索引

MyISAM引擎索引底层数据结构：B+Tree加强版的多路平衡二叉树



### 1） MyISAM索引物理存储位置

在MyISAM 里面，有两个文件：
一个是.MYD 文件，D 代表Data，是MyISAM 的数据文件，存放数据记录，比如我们的user_myisam 表的所有的表数据：一个是.MYI 文件，I 代表Index，是MyISAM 的索引文件，存放索引，比如我们在id 字段上面创建了一个主键索引，那么主键索引就是在这个索引文件里面。也就是说，在MyISAM 里面，索引和数据是两个独立的文件。



那我们怎么根据索引找到数据呢？
		MyISAM 的B+Tree 里面，叶子节点存储的是数据文件对应的磁盘地址。所以从索引文件.MYI 中找到键值后，会到数据文件.MYD 中获取相应的数据记录。

### 2） MyISAM 索引单个/多级索引逻辑查询

在MyISAM 里面，辅助索引也在这个.MYI 文件里面。
			辅助索引跟主键索引存储和检索数据的方式是没有任何区别的，一样是在索引文件里面找到磁盘地址，然后到数据文件里面获取数据。

![lBwFnP.png](https://s2.ax1x.com/2020/01/05/lBwFnP.png)



## 3.3  InnoDB 和 Myisam 引擎的B+Tree 树 比对
    1. InnoDB 辅助索引不存储数据的信息（或者索引）就是为了避免数据地址发生迁移的时候不会跟着修改辅助索引的叶节点信息。这也是Myisam做查询比较快，而InnoDB在综合更好。
    2.InnoDB是一个文件IBD,Myisam是两个文件MYI，MYD
    3.InnoDB索引和数据存储在一个文件，Myisam的索引和数据时存储在两个文件中


# 4.索引的使用规则

​	我们容易有以一个误区，就是在经常使用的查询条件上都建立索引，索引越多越好，那到底是不是这样呢？

其实使用原则都可以通过B+Tree的特性来分析，减少页的分裂，减少页分支的查询；即IO的交互就可以了；



## 4.1 列的离散度

第一个叫做列的离散度，我们先来看一下列的离散度的公式：

```sql
count(distinct(column_name)) : count(*)
-- 列的全部不同值和所有数据行的比例。
-- 数据行数相同的情况下，分子越大，列的离散度就越高。

-- 
简单来说，如果列的重复值越多，离散度就越低，重复值越少，离散度就越高。

了解了离散度的概念之后，我们再来思考一个问题，我们在name 上面建立索引和在gender 上面建立索引有什么区别。
当我们用在gender 上建立的索引去检索数据的时候，由于重复值太多，需要扫描的行数就更多
```

如果在B+Tree 里面的重复值太多，MySQL 的优化器发现走索引跟使用全表扫描差不了多少的时候，就算建了索引，也不一定会走索引

## 4.2 联合索引最左匹配

​		前面我们说的都是针对单列创建的索引，但有的时候我们的多条件查询的时候，也会建立联合索引。单列索引可以看成是特殊的联合索引。；这个也可以参考B+Tree第一个条件不能查询就不能用到索引了；

 **单列索引**
         节点中关键字[name]
   **联合索引**
          节点中关键字[name,phoneNum]
**联合索引列选择原则：**
       1 ，经常用的列优先 【 【 最左匹配原则 】
       2 ，选择性（离散度）高的列 优先 【 离散度高原则 】
       3 ，宽度小的列 优先 【 最少空间原则 】

## 4.3 覆盖索引

**回表：**
          非主键索引，我们先通过索引找到主键索引的键值，再通过主键值查出索引里面没有的数据，它比基于主键索引的查询多扫描了一棵索引树，这个过程就叫回表。

​	

**覆盖索引：**在辅助索引里面，不管是单列索引还是联合索引，如果select 的数据列只用从索引中就能够取得，不必从数据区中读取，这时候使用的索引就叫做覆盖索引，这样就避免了回表。这样也可以避免多次IO了；这也是为什么我们要减少"select * " 的使用，因为有可能会使用到覆盖索引。
     

## 4.4 索引下推

​        索引条件下推（Index Condition Pushdown），5.6 以后完善的功能。只适用于二级索引。ICP 的目标是减少访问表的完整行的读数量从而减少I/O 操作。

```sql
show variables like 'optimizer_switch';
set optimizer_switch='index_condition_pushdown=on';
```





# 5.索引创建和使用

因为索引对于改善查询性能的作用是巨大的，所以我们的目标是尽量使用索引



## 5.1 索引的创建

- 1、在用于where 判断order 排序和join 的（on）字段上创建索引

- 2、索引的个数不要过多。——浪费空间，更新变慢。

- 3、区分度低的字段，例如性别，不要建索引。——离散度太低，导致扫描行数过多。

- 4、频繁更新的值，不要作为主键或者索引。——页分裂

- 5、组合索引把散列性高（区分度高）的值放在前面。

- 6、创建复合索引，而不是修改单列索引。

- 7、过长的字段，怎么建立索引？ -- 全文索引

- 8、为什么不建议用无序的值（例如身份证、UUID ）作为索引？

    索引过长；每个页节点可以存储更多的数据



## 5.2. 什么时候用不到索引？

- 1、查询条件中索引列上使用函数（replace\SUBSTR\CONCAT\sum count avg）、表达式、计算（+ - * /）：

- 2、字符串不加引号，出现隐式转换

- 3、like 条件中前面带%

- 4、负向查询

  - NOT LIKE 不能：

  - != （<>）和NOT IN 在某些情况下可以

    ```text
    注意一个SQL 语句是否使用索引，跟数据库版本、数据量、数据选择度都有关系。
    其实，用不用索引，最终都是优化器说了算。
    
    优化器是基于什么的优化器？
    	基于cost 开销（Cost Base Optimizer），它不是基于规则（Rule-Based Optimizer），也不是基于语义。怎么样开销小就怎么来。
    https://docs.oracle.com/cd/B10501_01/server.920/a96533/rbo.htm#38960
    https://dev.mysql.com/doc/refman/5.7/en/cost-model.html
    ```

    